{
    "docs": [
        {
            "location": "/", 
            "text": "RCall.jl\n\n\nR\n has been round for a couple of decades.  In the last few years, a new language for technical computing, \nJulia\n, has arrived and provides remarkable performance via Just-In-Time (JIT) compilation of functions than in R, but there are still a lot of well-developed packages in R that could use in Julia.  The \nRCall\n package is a way of establishing communication between to two.\n\n\nIt is a pure Julia package.  In other words, there is no code in C or C++ or another such language necessary to implement calling R from Julia. It is possible to exploit the advantages of both languages.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#rcalljl", 
            "text": "R  has been round for a couple of decades.  In the last few years, a new language for technical computing,  Julia , has arrived and provides remarkable performance via Just-In-Time (JIT) compilation of functions than in R, but there are still a lot of well-developed packages in R that could use in Julia.  The  RCall  package is a way of establishing communication between to two.  It is a pure Julia package.  In other words, there is no code in C or C++ or another such language necessary to implement calling R from Julia. It is possible to exploit the advantages of both languages.", 
            "title": "RCall.jl"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing RCall.jl\n\n\nRCall.jl requires that a recent version of R, at least 3.2.0, be installed. \n\n\n\n\nStandard installations\n\n\nIf R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with\n\n\nPkg.add(\nRCall\n)\n\n\n\n\nShould you experience problems with any of these methods, please \nopen an issue\n.\n\n\n\n\nWindows\n\n\nThe current \nWindows binary from CRAN\n.\n\n\n\n\nOS X\n\n\nThe \nCRAN .pkg\n or the \nhomebrew/science\n tap.\n\n\n\n\nLinux\n\n\nMost Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from \nCRAN\n.\n\n\n\n\nUbuntu\n\n\nThe following will update R on recent versions of Ubuntu:\n\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y \ndeb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/\n\nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev\n\n\n\n\n\n\nUpdating R\n\n\nIf you have updated the R installation, you may need to rebuild the RCall cache via\n\n\nBase.compilecache(\nRCall\n)\n\n\n\n\n\n\nOther methods\n\n\nIf you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).\n\n\nFirstly, try setting the \nR_HOME\n environmental variable to the location of your R installation, which can be found by running \nR.home()\n from within R. This can be set in your \n~/.juliarc.jl\n file via the \nENV\n global variable, e.g.\n\n\nENV[\nR_HOME\n] = ...\n\n\n\n\n\n\nWindows PATH\n\n\nThe \nPATH\n environmental variable should contain the location of your R binary, and the \nHOME\n variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-rcalljl", 
            "text": "RCall.jl requires that a recent version of R, at least 3.2.0, be installed.", 
            "title": "Installing RCall.jl"
        }, 
        {
            "location": "/installation/#standard-installations", 
            "text": "If R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with  Pkg.add( RCall )  Should you experience problems with any of these methods, please  open an issue .", 
            "title": "Standard installations"
        }, 
        {
            "location": "/installation/#windows", 
            "text": "The current  Windows binary from CRAN .", 
            "title": "Windows"
        }, 
        {
            "location": "/installation/#os-x", 
            "text": "The  CRAN .pkg  or the  homebrew/science  tap.", 
            "title": "OS X"
        }, 
        {
            "location": "/installation/#linux", 
            "text": "Most Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from  CRAN .", 
            "title": "Linux"
        }, 
        {
            "location": "/installation/#ubuntu", 
            "text": "The following will update R on recent versions of Ubuntu:  sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y  deb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/ \nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/installation/#updating-r", 
            "text": "If you have updated the R installation, you may need to rebuild the RCall cache via  Base.compilecache( RCall )", 
            "title": "Updating R"
        }, 
        {
            "location": "/installation/#other-methods", 
            "text": "If you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).  Firstly, try setting the  R_HOME  environmental variable to the location of your R installation, which can be found by running  R.home()  from within R. This can be set in your  ~/.juliarc.jl  file via the  ENV  global variable, e.g.  ENV[ R_HOME ] = ...", 
            "title": "Other methods"
        }, 
        {
            "location": "/installation/#windows-path", 
            "text": "The  PATH  environmental variable should contain the location of your R binary, and the  HOME  variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Windows PATH"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\n\n\nTypes\n\n\n#\n\n\nRCall.RObject\n \n \nType\n.\n\n\n\n\nAn \nRObject\n is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the \nRObject\n itself is finalized by Julia. The parameter is the type of the S-expression.\n\n\nWhen called with a Julia object as an argument, a corresponding R object is constructed.\n\n\njulia\n RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia\n RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia\n RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3\n\n\n\n\n#\n\n\nRCall.Sxp\n \n \nType\n.\n\n\n\n\nR symbolic expression (\nSxpPtr\n): these are represented by a pointer to a symbolic expression record (\nSxp\n).\n\n\n#\n\n\nRCall.NilSxp\n \n \nType\n.\n\n\n\n\nR NULL value\n\n\n#\n\n\nRCall.StrSxp\n \n \nType\n.\n\n\n\n\nR vector of character strings\n\n\n#\n\n\nRCall.CharSxp\n \n \nType\n.\n\n\n\n\nR character string\n\n\n#\n\n\nRCall.LglSxp\n \n \nType\n.\n\n\n\n\nR logical vector\n\n\n#\n\n\nRCall.IntSxp\n \n \nType\n.\n\n\n\n\nR integer vector\n\n\n#\n\n\nRCall.RealSxp\n \n \nType\n.\n\n\n\n\nR real vector\n\n\n#\n\n\nRCall.CplxSxp\n \n \nType\n.\n\n\n\n\nR complex vector\n\n\n#\n\n\nRCall.ClosSxp\n \n \nType\n.\n\n\n\n\nR function closure\n\n\n\n\nMethods\n\n\n#\n\n\nRCall.getAttrib\n \n \nFunction\n.\n\n\n\n\nReturn a particular attribute of an RObject\n\n\n#\n\n\nRCall.setAttrib!\n \n \nFunction\n.\n\n\n\n\nSet a particular attribute of an RObject\n\n\n#\n\n\nRCall.getNames\n \n \nFunction\n.\n\n\n\n\nReturns the names of an R vector.\n\n\n#\n\n\nRCall.setNames!\n \n \nFunction\n.\n\n\n\n\nSet the names of an R vector.\n\n\n#\n\n\nRCall.rcopy\n \n \nFunction\n.\n\n\n\n\nrcopy(T,p)\n converts a pointer \np\n to a Sxp object to a native Julia object of type T.\n\n\nrcopy(p)\n performs a default conversion.\n\n\nrcopy\n copies the contents of an R object into a corresponding canonical Julia type.\n\n\nEvaluate and convert the result of a string as an R expression.\n\n\n#\n\n\nRCall.rparse\n \n \nFunction\n.\n\n\n\n\nParse a string as an R expression, returning an RObject.\n\n\n#\n\n\nRCall.rprint\n \n \nFunction\n.\n\n\n\n\nPrint the value of an Sxp using R's printing mechanism\n\n\nParse, evaluate and print the result of a string as an R expression.\n\n\n#\n\n\nRCall.reval\n \n \nFunction\n.\n\n\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.\n\n\n#\n\n\nRCall.rcall\n \n \nFunction\n.\n\n\n\n\nEvaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.\n\n\n#\n\n\nRCall.rlang\n \n \nFunction\n.\n\n\n\n\nCreate a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated\n\n\n#\n\n\nRCall.isNA\n \n \nFunction\n.\n\n\n\n\nCheck if values correspond to R's sentinel NA values.\n\n\n#\n\n\nRCall.anyNA\n \n \nFunction\n.\n\n\n\n\nCheck if there are any NA values in the vector.\n\n\n#\n\n\nRCall.isFactor\n \n \nFunction\n.\n\n\n\n\nCheck whether an R variable is a factor variable\n\n\n#\n\n\nRCall.isOrdered\n \n \nFunction\n.\n\n\n\n\nCheck whether an R variable is an ordered factor variable\n\n\n\n\nMacros\n\n\n#\n\n\nRCall.@rimport\n \n \nMacro\n.\n\n\n\n\nImport a R Package as a Julia module. You can also use classic Python syntax to make an alias: \n@rimport *module-name* as *shorthand*\n\n\n#\n\n\nRCall.@rlibrary\n \n \nMacro\n.\n\n\n\n\nLoad all exported functions/objects of a R package to the current module.\n\n\n#\n\n\nRCall.@rput\n \n \nMacro\n.\n\n\n\n\nCopies variables from Julia to R using the same name.\n\n\n#\n\n\nRCall.@rget\n \n \nMacro\n.\n\n\n\n\nCopies variables from R to Julia using the same name.\n\n\n#\n\n\nRCall.@var_str\n \n \nMacro\n.\n\n\n\n\nReturns a variable named \"str\". Useful for passing keyword arguments containing dots.\n\n\n#\n\n\nRCall.@R_str\n \n \nMacro\n.\n\n\n\n\nAllows inline R scripts, e.g\n\n\nfoo = R\nglm(Sepal.Length ~ Sepal.Width, data=$iris)\n\n\n\n\n\nDoes not yet support assigning to Julia variables, so can only return results.\n\n\n\n\nVariables\n\n\n#\n\n\nRCall.globalEnv\n \n \nConstant\n.\n\n\n\n\nR global Environment.\n\n\nglobalEnv[:x] = 1\nglobalEnv[:x]", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#types", 
            "text": "#  RCall.RObject     Type .   An  RObject  is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the  RObject  itself is finalized by Julia. The parameter is the type of the S-expression.  When called with a Julia object as an argument, a corresponding R object is constructed.  julia  RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia  RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia  RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3  #  RCall.Sxp     Type .   R symbolic expression ( SxpPtr ): these are represented by a pointer to a symbolic expression record ( Sxp ).  #  RCall.NilSxp     Type .   R NULL value  #  RCall.StrSxp     Type .   R vector of character strings  #  RCall.CharSxp     Type .   R character string  #  RCall.LglSxp     Type .   R logical vector  #  RCall.IntSxp     Type .   R integer vector  #  RCall.RealSxp     Type .   R real vector  #  RCall.CplxSxp     Type .   R complex vector  #  RCall.ClosSxp     Type .   R function closure", 
            "title": "Types"
        }, 
        {
            "location": "/lib/public/#methods", 
            "text": "#  RCall.getAttrib     Function .   Return a particular attribute of an RObject  #  RCall.setAttrib!     Function .   Set a particular attribute of an RObject  #  RCall.getNames     Function .   Returns the names of an R vector.  #  RCall.setNames!     Function .   Set the names of an R vector.  #  RCall.rcopy     Function .   rcopy(T,p)  converts a pointer  p  to a Sxp object to a native Julia object of type T.  rcopy(p)  performs a default conversion.  rcopy  copies the contents of an R object into a corresponding canonical Julia type.  Evaluate and convert the result of a string as an R expression.  #  RCall.rparse     Function .   Parse a string as an R expression, returning an RObject.  #  RCall.rprint     Function .   Print the value of an Sxp using R's printing mechanism  Parse, evaluate and print the result of a string as an R expression.  #  RCall.reval     Function .   Evaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.  #  RCall.rcall     Function .   Evaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.  #  RCall.rlang     Function .   Create a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated  #  RCall.isNA     Function .   Check if values correspond to R's sentinel NA values.  #  RCall.anyNA     Function .   Check if there are any NA values in the vector.  #  RCall.isFactor     Function .   Check whether an R variable is a factor variable  #  RCall.isOrdered     Function .   Check whether an R variable is an ordered factor variable", 
            "title": "Methods"
        }, 
        {
            "location": "/lib/public/#macros", 
            "text": "#  RCall.@rimport     Macro .   Import a R Package as a Julia module. You can also use classic Python syntax to make an alias:  @rimport *module-name* as *shorthand*  #  RCall.@rlibrary     Macro .   Load all exported functions/objects of a R package to the current module.  #  RCall.@rput     Macro .   Copies variables from Julia to R using the same name.  #  RCall.@rget     Macro .   Copies variables from R to Julia using the same name.  #  RCall.@var_str     Macro .   Returns a variable named \"str\". Useful for passing keyword arguments containing dots.  #  RCall.@R_str     Macro .   Allows inline R scripts, e.g  foo = R glm(Sepal.Length ~ Sepal.Width, data=$iris)   Does not yet support assigning to Julia variables, so can only return results.", 
            "title": "Macros"
        }, 
        {
            "location": "/lib/public/#variables", 
            "text": "#  RCall.globalEnv     Constant .   R global Environment.  globalEnv[:x] = 1\nglobalEnv[:x]", 
            "title": "Variables"
        }
    ]
}