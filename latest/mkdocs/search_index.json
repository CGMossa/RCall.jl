{
    "docs": [
        {
            "location": "/", 
            "text": "RCall.jl\n\n\nR\n is a language for statistical computing and graphics that has been around for couple of decades and it has one of the most impressive collections of scientific and statistical packages of any environment. Recently, the \nJulia\n language has become an attractive alternative because it provides the remarkable performance of a low-level language without sacrificing the readability and ease-of-use of high-level languages. However, Julia still lacks the depth and scale of the R package environment.\n\n\nThis package, \nRCall\n, facilitates communication between these two languages and allows the user to call R packages from within Julia, providing the best of both worlds. Additionally, this is a pure Julia package so it is portable and easy to use.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#rcalljl", 
            "text": "R  is a language for statistical computing and graphics that has been around for couple of decades and it has one of the most impressive collections of scientific and statistical packages of any environment. Recently, the  Julia  language has become an attractive alternative because it provides the remarkable performance of a low-level language without sacrificing the readability and ease-of-use of high-level languages. However, Julia still lacks the depth and scale of the R package environment.  This package,  RCall , facilitates communication between these two languages and allows the user to call R packages from within Julia, providing the best of both worlds. Additionally, this is a pure Julia package so it is portable and easy to use.", 
            "title": "RCall.jl"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing RCall.jl\n\n\nRCall.jl requires that a recent version of R, at least 3.2.0, be installed. \n\n\n\n\nStandard installations\n\n\nIf R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with\n\n\nPkg.add(\nRCall\n)\n\n\n\n\nShould you experience problems with any of these methods, please \nopen an issue\n.\n\n\n\n\nWindows\n\n\nThe current \nWindows binary from CRAN\n.\n\n\n\n\nOS X\n\n\nThe \nCRAN .pkg\n or the \nhomebrew/science\n tap.\n\n\n\n\nLinux\n\n\nMost Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from \nCRAN\n.\n\n\n\n\nUbuntu\n\n\nThe following will update R on recent versions of Ubuntu:\n\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y \ndeb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/\n\nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev\n\n\n\n\n\n\nUpdating R\n\n\nIf you have updated the R installation, you may need to rebuild the RCall cache via\n\n\nBase.compilecache(\nRCall\n)\n\n\n\n\n\n\nOther methods\n\n\nIf you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).\n\n\nFirstly, try setting the \nR_HOME\n environmental variable to the location of your R installation, which can be found by running \nR.home()\n from within R. This can be set in your \n~/.juliarc.jl\n file via the \nENV\n global variable, e.g.\n\n\nENV[\nR_HOME\n] = ...\n\n\n\n\nYou may also need to specify the variable \nLD_LIBRARY_PATH\n before launching Julia, for example\n\n\nexport LD_LIBRARY_PATH=\n`R RHOME`/lib\n\njulia\n\n\n\n\n\n\nWindows PATH\n\n\nThe \nPATH\n environmental variable should contain the location of your R binary, and the \nHOME\n variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-rcalljl", 
            "text": "RCall.jl requires that a recent version of R, at least 3.2.0, be installed.", 
            "title": "Installing RCall.jl"
        }, 
        {
            "location": "/installation/#standard-installations", 
            "text": "If R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with  Pkg.add( RCall )  Should you experience problems with any of these methods, please  open an issue .", 
            "title": "Standard installations"
        }, 
        {
            "location": "/installation/#windows", 
            "text": "The current  Windows binary from CRAN .", 
            "title": "Windows"
        }, 
        {
            "location": "/installation/#os-x", 
            "text": "The  CRAN .pkg  or the  homebrew/science  tap.", 
            "title": "OS X"
        }, 
        {
            "location": "/installation/#linux", 
            "text": "Most Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from  CRAN .", 
            "title": "Linux"
        }, 
        {
            "location": "/installation/#ubuntu", 
            "text": "The following will update R on recent versions of Ubuntu:  sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y  deb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/ \nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/installation/#updating-r", 
            "text": "If you have updated the R installation, you may need to rebuild the RCall cache via  Base.compilecache( RCall )", 
            "title": "Updating R"
        }, 
        {
            "location": "/installation/#other-methods", 
            "text": "If you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).  Firstly, try setting the  R_HOME  environmental variable to the location of your R installation, which can be found by running  R.home()  from within R. This can be set in your  ~/.juliarc.jl  file via the  ENV  global variable, e.g.  ENV[ R_HOME ] = ...  You may also need to specify the variable  LD_LIBRARY_PATH  before launching Julia, for example  export LD_LIBRARY_PATH= `R RHOME`/lib \njulia", 
            "title": "Other methods"
        }, 
        {
            "location": "/installation/#windows-path", 
            "text": "The  PATH  environmental variable should contain the location of your R binary, and the  HOME  variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Windows PATH"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "Getting started\n\n\nThe RCall package is loaded via\n\n\njulia\n using RCall\n\n\n\n\nThis will initialize the R process in the background.\n\n\n\n\nSeveral Ways to use RCall\n\n\nRCall provides multiple ways to allow R interacting with Julia. \n\n\n\n\nR REPL mode\n\n\n@rput\n and \n@rget\n macros\n\n\nR\"\"\n string macro\n\n\nA low level API: \nreval\n, \nrcall\n and \nrcopy\n etc.\n\n\n\n\n\n\nR REPL mode\n\n\nThe R REPL mode allows real time switching between the Julia prompt and R promot. Press \n$\n to activate the R REPL mode and the R prompt will be shown. (Press \nbackspace\n to leave R REPL mode in case you did not know.)\n\n\njulia\n foo = 1\n1\n\nR\n x \n- $foo\n\nR\n x\n[1] 1\n\n\n\n\nThe R REPL mode supports variable substitution of Julia objects via the \n$\n symbol. It is also possible to pass Julia expressions in the REPL mode.\n\n\nR\n x = $(rand(10))\n\nR\n sum(x)\n[1] 5.097083\n\n\n\n\n\n\n@rput and @rget macros\n\n\nThese macros transfer variables between R and Julia environments. The copied variable will have the same name as the original.\n\n\njulia\n z = 1\n1\n\njulia\n @rput z\n1\n\nR\n z\n[1] 1\n\nR\n r = 2\n\njulia\n @rget r\n2.0\n\njulia\n r\n2.0\n\n\n\n\nIt is also possible to put and get multiple variables in one line.\n\n\njulia\n foo = 2\n2\n\njulia\n bar = 4\n4\n\njulia\n @rput foo bar\n4\n\nR\n foo + bar\n[1] 6\n\n\n\n\n\n\n@R_str string macro\n\n\nAnother way to use RCall is the \nR\"\"\n string macro, it is especially useful in script files.\n\n\njulia\n R\nrnorm(10)\n\nRCall.RObject{RCall.RealSxp}\n [1] -0.50351758  1.48992394  1.42310348 -1.30111669 -0.61300846  0.14351584\n [7]  3.04597267  0.22225650 -0.04404591  0.22044506\n\n\n\n\nThis evaluates the expression inside the string in R, and returns the result as an \nRObject\n, which is a Julia wrapper type around an R object.\n\n\nThe \nR\"\"\n string macro supports variable substitution of Julia objects via the \n$\n symbol, whenever it is not valid R syntax (i.e. when not directly following a symbol or completed expression such as \naa$bb\n):\n\n\njulia\n x = randn(10)\n10-element Array{Float64,1}:\n  0.0725732\n  0.157035\n  0.95697\n -0.644087\n -0.620308\n  0.243797\n -0.127673\n  0.0210906\n  0.040765\n -2.25238\n\njulia\n R\nt.test($x)\n\nRCall.RObject{RCall.VecSxp}\n\n    One Sample t-test\n\ndata:  `#JL`$x\nt = -0.805, df = 9, p-value = 0.4416\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n -0.8200277  0.3895836\nsample estimates:\n mean of x\n-0.2152221\n\n\n\n\nIt is also possible to pass Julia expressions which are evaluated before being passed to R: these should be included in parentheses\n\n\njulia\n R\noptim(0, $(x -\n x-cos(x)), method='BFGS')\n\nRCall.RObject{RCall.VecSxp}\n$par\n[1] -1.56343\n\n$value\n[1] -1.570796\n\n$counts\nfunction gradient\n      14       13\n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\nA large chunk of code could be quoted between triple string quotations\n\n\njulia\n y = 1\n1\n\njulia\n R\n\n       f \n- function(x, y) x + y\n       ret \n- f(1, $y)\n       \n\nRCall.RObject{RCall.RealSxp}\n[1] 2\n\n\n\n\n\n\nRCall API\n\n\nThe \nreval\n function evaluates any given input string as R code in the R environment. The returned result is an \nRObject\n object.\n\n\njulia\n jmtcars = reval(\nmtcars\n);\n\njulia\n names(jmtcars)\n11-element Array{Symbol,1}:\n :mpg\n :cyl\n :disp\n :hp\n :drat\n :wt\n :qsec\n :vs\n :am\n :gear\n :carb\n\njulia\n jmtcars[:mpg]\nRCall.RObject{RCall.RealSxp}\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\njulia\n typeof(jmtcars)\nRCall.RObject{RCall.VecSxp}\n\n\n\n\nThe \nrcall\n function is used to construct function calls.\n\n\njulia\n rcall(:dim, jmtcars)\nRCall.RObject{RCall.IntSxp}\n[1] 32 11\n\n\n\n\nThe arguments will be implicitly converted to \nRObject\n upon evaluation.\n\n\njulia\n rcall(:sum, Float64[1.0, 4.0, 6.0])\nRCall.RObject{RCall.RealSxp}\n[1] 11\n\n\n\n\nThe \nrcopy\n function converts \nRObject\ns to Julia objects. It uses a variety of heuristics to pick the most appropriate Julia type:\n\n\njulia\n rcopy(R\nc(1)\n)\n1.0\n\njulia\n rcopy(R\nc(1,2)\n)\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\njulia\n rcopy(R\nlist(1,'zz')\n)\n2-element Array{Any,1}:\n 1.0\n  \nzz\n\n\njulia\n rcopy(R\nlist(a=1,b='zz')\n)\nDict{Symbol,Any} with 2 entries:\n  :a =\n 1.0\n  :b =\n \nzz\n\n\n\n\n\nIt is possible to force a specific conversion by passing the output type as the first argument:\n\n\njulia\n rcopy(Array{Int},R\nc(1,2)\n)\n2-element Array{Int64,1}:\n 1\n 2", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#getting-started", 
            "text": "The RCall package is loaded via  julia  using RCall  This will initialize the R process in the background.", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#several-ways-to-use-rcall", 
            "text": "RCall provides multiple ways to allow R interacting with Julia.    R REPL mode  @rput  and  @rget  macros  R\"\"  string macro  A low level API:  reval ,  rcall  and  rcopy  etc.", 
            "title": "Several Ways to use RCall"
        }, 
        {
            "location": "/gettingstarted/#r-repl-mode", 
            "text": "The R REPL mode allows real time switching between the Julia prompt and R promot. Press  $  to activate the R REPL mode and the R prompt will be shown. (Press  backspace  to leave R REPL mode in case you did not know.)  julia  foo = 1\n1\n\nR  x  - $foo\n\nR  x\n[1] 1  The R REPL mode supports variable substitution of Julia objects via the  $  symbol. It is also possible to pass Julia expressions in the REPL mode.  R  x = $(rand(10))\n\nR  sum(x)\n[1] 5.097083", 
            "title": "R REPL mode"
        }, 
        {
            "location": "/gettingstarted/#rput-and-rget-macros", 
            "text": "These macros transfer variables between R and Julia environments. The copied variable will have the same name as the original.  julia  z = 1\n1\n\njulia  @rput z\n1\n\nR  z\n[1] 1\n\nR  r = 2\n\njulia  @rget r\n2.0\n\njulia  r\n2.0  It is also possible to put and get multiple variables in one line.  julia  foo = 2\n2\n\njulia  bar = 4\n4\n\njulia  @rput foo bar\n4\n\nR  foo + bar\n[1] 6", 
            "title": "@rput and @rget macros"
        }, 
        {
            "location": "/gettingstarted/#r_str-string-macro", 
            "text": "Another way to use RCall is the  R\"\"  string macro, it is especially useful in script files.  julia  R rnorm(10) \nRCall.RObject{RCall.RealSxp}\n [1] -0.50351758  1.48992394  1.42310348 -1.30111669 -0.61300846  0.14351584\n [7]  3.04597267  0.22225650 -0.04404591  0.22044506  This evaluates the expression inside the string in R, and returns the result as an  RObject , which is a Julia wrapper type around an R object.  The  R\"\"  string macro supports variable substitution of Julia objects via the  $  symbol, whenever it is not valid R syntax (i.e. when not directly following a symbol or completed expression such as  aa$bb ):  julia  x = randn(10)\n10-element Array{Float64,1}:\n  0.0725732\n  0.157035\n  0.95697\n -0.644087\n -0.620308\n  0.243797\n -0.127673\n  0.0210906\n  0.040765\n -2.25238\n\njulia  R t.test($x) \nRCall.RObject{RCall.VecSxp}\n\n    One Sample t-test\n\ndata:  `#JL`$x\nt = -0.805, df = 9, p-value = 0.4416\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n -0.8200277  0.3895836\nsample estimates:\n mean of x\n-0.2152221  It is also possible to pass Julia expressions which are evaluated before being passed to R: these should be included in parentheses  julia  R optim(0, $(x -  x-cos(x)), method='BFGS') \nRCall.RObject{RCall.VecSxp}\n$par\n[1] -1.56343\n\n$value\n[1] -1.570796\n\n$counts\nfunction gradient\n      14       13\n\n$convergence\n[1] 0\n\n$message\nNULL  A large chunk of code could be quoted between triple string quotations  julia  y = 1\n1\n\njulia  R \n       f  - function(x, y) x + y\n       ret  - f(1, $y)\n        \nRCall.RObject{RCall.RealSxp}\n[1] 2", 
            "title": "@R_str string macro"
        }, 
        {
            "location": "/gettingstarted/#rcall-api", 
            "text": "The  reval  function evaluates any given input string as R code in the R environment. The returned result is an  RObject  object.  julia  jmtcars = reval( mtcars );\n\njulia  names(jmtcars)\n11-element Array{Symbol,1}:\n :mpg\n :cyl\n :disp\n :hp\n :drat\n :wt\n :qsec\n :vs\n :am\n :gear\n :carb\n\njulia  jmtcars[:mpg]\nRCall.RObject{RCall.RealSxp}\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\njulia  typeof(jmtcars)\nRCall.RObject{RCall.VecSxp}  The  rcall  function is used to construct function calls.  julia  rcall(:dim, jmtcars)\nRCall.RObject{RCall.IntSxp}\n[1] 32 11  The arguments will be implicitly converted to  RObject  upon evaluation.  julia  rcall(:sum, Float64[1.0, 4.0, 6.0])\nRCall.RObject{RCall.RealSxp}\n[1] 11  The  rcopy  function converts  RObject s to Julia objects. It uses a variety of heuristics to pick the most appropriate Julia type:  julia  rcopy(R c(1) )\n1.0\n\njulia  rcopy(R c(1,2) )\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\njulia  rcopy(R list(1,'zz') )\n2-element Array{Any,1}:\n 1.0\n   zz \n\njulia  rcopy(R list(a=1,b='zz') )\nDict{Symbol,Any} with 2 entries:\n  :a =  1.0\n  :b =   zz   It is possible to force a specific conversion by passing the output type as the first argument:  julia  rcopy(Array{Int},R c(1,2) )\n2-element Array{Int64,1}:\n 1\n 2", 
            "title": "RCall API"
        }, 
        {
            "location": "/internal/", 
            "text": "Internal API\n\n\n\n\nTypes\n\n\n#\n\n\nRCall.AnySxp\n \n \nType\n.\n\n\nR \"any\" object\n\n\n#\n\n\nRCall.BcodeSxp\n \n \nType\n.\n\n\nR byte code\n\n\n#\n\n\nRCall.BuiltinSxp\n \n \nType\n.\n\n\nR built-in function\n\n\n#\n\n\nRCall.CharSxp\n \n \nType\n.\n\n\nR character string\n\n\n#\n\n\nRCall.ClosSxp\n \n \nType\n.\n\n\nR function closure\n\n\n#\n\n\nRCall.CplxSxp\n \n \nType\n.\n\n\nR complex vector\n\n\n#\n\n\nRCall.DotSxp\n \n \nType\n.\n\n\nR dot-dot-dot object\n\n\n#\n\n\nRCall.EnvSxp\n \n \nType\n.\n\n\nR environment\n\n\n#\n\n\nRCall.ExprSxp\n \n \nType\n.\n\n\nR expression vector\n\n\n#\n\n\nRCall.ExtPtrSxp\n \n \nType\n.\n\n\nR external pointer\n\n\n#\n\n\nRCall.IntSxp\n \n \nType\n.\n\n\nR integer vector\n\n\n#\n\n\nRCall.LangSxp\n \n \nType\n.\n\n\nR function call\n\n\n#\n\n\nRCall.LglSxp\n \n \nType\n.\n\n\nR logical vector\n\n\n#\n\n\nRCall.ListSxp\n \n \nType\n.\n\n\nR pairs (cons) list cell\n\n\n#\n\n\nRCall.NilSxp\n \n \nType\n.\n\n\nR NULL value\n\n\n#\n\n\nRCall.PromSxp\n \n \nType\n.\n\n\nR promise\n\n\n#\n\n\nRCall.RObject\n \n \nType\n.\n\n\nAn \nRObject\n is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the \nRObject\n itself is finalized by Julia. The parameter is the type of the S-expression.\n\n\nWhen called with a Julia object as an argument, a corresponding R object is constructed.\n\n\njulia\n RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia\n RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia\n RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3\n\n\n\n\n#\n\n\nRCall.RawSxp\n \n \nType\n.\n\n\nR byte vector\n\n\n#\n\n\nRCall.RealSxp\n \n \nType\n.\n\n\nR real vector\n\n\n#\n\n\nRCall.S4Sxp\n \n \nType\n.\n\n\nR S4 object\n\n\n#\n\n\nRCall.SpecialSxp\n \n \nType\n.\n\n\nR special function\n\n\n#\n\n\nRCall.StrSxp\n \n \nType\n.\n\n\nR vector of character strings\n\n\n#\n\n\nRCall.Sxp\n \n \nType\n.\n\n\nRCall.jl's type \nSxp\n mirrors the R symbolic expression record \nSEXPREC\n in R API. These are represented by a pointer \nSxpPtr\n (which is called \nSEXP\n in R API).\n\n\n#\n\n\nRCall.SxpHead\n \n \nType\n.\n\n\nR Sxp header: a pointer to this is used for unknown types.\n\n\n#\n\n\nRCall.SymSxp\n \n \nType\n.\n\n\nR symbol\n\n\n#\n\n\nRCall.VecSxp\n \n \nType\n.\n\n\nR list (i.e. Array{Any,1})\n\n\n#\n\n\nRCall.WeakRefSxp\n \n \nType\n.\n\n\nR weak reference\n\n\n\n\nMethods\n\n\n#\n\n\nBase.eltype\n \n \nMethod\n.\n\n\nElement types of R vectors.\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nextract the value of symbol s in the environment e\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nextract the i-th element of LangSxp l\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nIndexing into \nVectorSxp\n types uses Julia indexing into the \nvec\n result, except for \nStrSxp\n and the \nVectorListSxp\n types, which must apply \nsexp\n to the \nPtr{Void}\n obtained by indexing into the \nvec\n result.\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nString indexing finds the first element with the matching name\n\n\n#\n\n\nBase.isascii\n \n \nMethod\n.\n\n\nDetermines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).  * 0x00_0002_00 (bit 1): set of bytes (no known encoding)  * 0x00_0004_00 (bit 2): Latin-1  * 0x00_0008_00 (bit 3): UTF-8  * 0x00_0040_00 (bit 6): ASCII\n\n\nWe only support ASCII and UTF-8.\n\n\n#\n\n\nBase.length\n \n \nMethod\n.\n\n\nSxp methods for \nlength\n return the R length.\n\n\nRf_xlength\n handles Sxps that are not vector-like and R's \"long vectors\", which have a negative value for the \nlength\n member.\n\n\n#\n\n\nBase.names\n \n \nMethod\n.\n\n\nReturns the names of an R vector, the result is converted to a Julia symbol array.\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nassign value v to symbol s in the environment e\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nassign value v to the i-th element of LangSxp l\n\n\n#\n\n\nRCall.anyna\n \n \nMethod\n.\n\n\nCheck if there are any NA values in the vector.\n\n\n#\n\n\nRCall.bound\n \n \nMethod\n.\n\n\nThe R NAMED property, represented by 2 bits in the info field. This can take values 0,1 or 2, corresponding to whether it is bound to 0,1 or 2 or more symbols. See http://cran.r-project.org/doc/manuals/r-patched/R-exts.html#Named-objects-and-copying\n\n\n#\n\n\nRCall.dataptr\n \n \nMethod\n.\n\n\nPointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.\n\n\n#\n\n\nRCall.decref_extptr\n \n \nMethod\n.\n\n\nCalled by the R finalizer.\n\n\n#\n\n\nRCall.endEmbeddedR\n \n \nMethod\n.\n\n\nendEmbeddedR()\n\n\n\n\nClose embedded R session.\n\n\n#\n\n\nRCall.event_callback\n \n \nMethod\n.\n\n\nEvent Callback: allows R to process Julia events when R is busy. For example, writing output to STDOUT while running an expensive R command.\n\n\n#\n\n\nRCall.findNamespace\n \n \nMethod\n.\n\n\nfind namespace by name of the namespace, it is not error tolerant.\n\n\n#\n\n\nRCall.getNamespace\n \n \nMethod\n.\n\n\nget namespace by name of the namespace. It is safer to be used than findNamespace as it checks bound.\n\n\n#\n\n\nRCall.getParseErrorMsg\n \n \nMethod\n.\n\n\nGet the R parser error msg for the previous parsing result.\n\n\n#\n\n\nRCall.getattrib\n \n \nMethod\n.\n\n\nReturn a particular attribute of an RObject\n\n\n#\n\n\nRCall.getclass\n \n \nMethod\n.\n\n\nReturns the class of an R object.\n\n\n#\n\n\nRCall.getnames\n \n \nMethod\n.\n\n\nReturns the names of an R vector.\n\n\n#\n\n\nRCall.ijulia_displayplots\n \n \nMethod\n.\n\n\nCalled after cell evaluation. Closes graphics device and displays files in notebook.\n\n\n#\n\n\nRCall.ijulia_setdevice\n \n \nMethod\n.\n\n\nSet options for R plotting with IJulia.\n\n\nThe first argument should be a MIME object: currently supported are * \nMIME(\"image/png\")\n [default] * \nMIME(\"image/svg+xml\")\n\n\nThe remaining arguments (keyword only) are passed to the appropriate R graphics device: see the relevant R help for details.\n\n\n#\n\n\nRCall.initEmbeddedR\n \n \nMethod\n.\n\n\ninitEmbeddedR()\n\n\n\n\nThis initializes an embedded R session. It should only be called when R is not already running (e.g. if Julia is running inside an R session)\n\n\n#\n\n\nRCall.isna\n \n \nMethod\n.\n\n\nCheck if values correspond to R's sentinel NA values.\n\n\n#\n\n\nRCall.isnull\n \n \nMethod\n.\n\n\nCheck if values correspond to R's NULL object.\n\n\n#\n\n\nRCall.julia_extptr_callback\n \n \nMethod\n.\n\n\nThe function called by R .External for Julia callbacks.\n\n\nIt receives a \nListSxpPtr\n containing  - a pointer to the function itself (\nExtPtrSxpPtr\n)  - a pointer to the Julia function (\nExtPtrSxpPtr\n)  - any arguments (as \nSxpPtr\n)\n\n\n#\n\n\nRCall.makeExternalPtr\n \n \nFunction\n.\n\n\nCreate an ExtPtrSxpPtr object\n\n\n#\n\n\nRCall.makeNativeSymbolRef\n \n \nMethod\n.\n\n\nRegister a function pointer as an R NativeSymbol.\n\n\nThis is completely undocumented, so may break: we technically are supposed to use R_registerRoutines, but this is \nmuch\n easier for just 1 function.\n\n\n#\n\n\nRCall.naeltype\n \n \nMethod\n.\n\n\nNA element for each type\n\n\n#\n\n\nRCall.newEnvironment\n \n \nMethod\n.\n\n\nnewEnvironment([env])\n\n\n\n\nCreate a new environment which extends environment \nenv\n (\nglobalEnv\n by default).\n\n\n#\n\n\nRCall.parseVector\n \n \nFunction\n.\n\n\nA pure julia wrapper of R_ParseVector\n\n\n#\n\n\nRCall.preserve\n \n \nMethod\n.\n\n\nPrevent garbage collection of an R object. Object can be released via \nrelease\n.\n\n\nThis is slower than \nprotect\n, as it requires searching an internal list, but more flexible.\n\n\n#\n\n\nRCall.protect\n \n \nMethod\n.\n\n\nStack-based protection of garbage collection of R objects. Objects are released via \nunprotect\n. Returns the same pointer, allowing inline use.\n\n\nThis is faster than \npreserve\n, but more restrictive. Really only useful inside functions.\n\n\n#\n\n\nRCall.rcall\n \n \nMethod\n.\n\n\nEvaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.\n\n\n#\n\n\nRCall.rcopy\n \n \nMethod\n.\n\n\nEvaluate and convert the result of a string as an R expression.\n\n\n#\n\n\nRCall.rcopy\n \n \nMethod\n.\n\n\nrcopy\n copies the contents of an R object into a corresponding canonical Julia type.\n\n\n#\n\n\nRCall.rcopy\n \n \nMethod\n.\n\n\nrcopy(T,p)\n converts a pointer \np\n to a Sxp object to a native Julia object of type T.\n\n\nrcopy(p)\n performs a default conversion.\n\n\n#\n\n\nRCall.registerCFinalizerEx\n \n \nMethod\n.\n\n\nRegister finalizer to be called by the R GC.\n\n\n#\n\n\nRCall.release\n \n \nMethod\n.\n\n\nRelease object that has been gc protected by \npreserve\n.\n\n\n#\n\n\nRCall.render\n \n \nMethod\n.\n\n\nRender an inline R script, substituting invalid \":($(Expr(:incomplete, \"incomplete: invalid string syntax\")))\n\n\n#\n\n\nRCall.reval\n \n \nFunction\n.\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.\n\n\n#\n\n\nRCall.reval_p\n \n \nMethod\n.\n\n\nEvaluate an R expression array iteratively.\n\n\n#\n\n\nRCall.reval_p\n \n \nMethod\n.\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning a Sxp pointer.\n\n\n#\n\n\nRCall.rlang\n \n \nMethod\n.\n\n\nCreate a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated\n\n\n#\n\n\nRCall.rlang_p\n \n \nMethod\n.\n\n\nCreate a function call from a list of arguments\n\n\n#\n\n\nRCall.rparse\n \n \nMethod\n.\n\n\nParse a string as an R expression, returning an RObject.\n\n\n#\n\n\nRCall.rparse_p\n \n \nMethod\n.\n\n\nParse a string as an R expression, returning a Sxp pointer.\n\n\n#\n\n\nRCall.rprint\n \n \nMethod\n.\n\n\nParse, evaluate and print the result of a string as an R expression.\n\n\n#\n\n\nRCall.rprint\n \n \nMethod\n.\n\n\nPrint the value of an Sxp using R's printing mechanism\n\n\n#\n\n\nRCall.setattrib!\n \n \nMethod\n.\n\n\nSet a particular attribute of an RObject\n\n\n#\n\n\nRCall.setclass!\n \n \nMethod\n.\n\n\nSet the class of an R object.\n\n\n#\n\n\nRCall.setnames!\n \n \nMethod\n.\n\n\nSet the names of an R vector.\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nCreate a \nStrSxp\n from an Abstract String Array\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nConvert a \nUnknownSxpPtr\n to an approptiate \nSxpPtr\n.\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nsexp(S,x)\n converts a Julia object \nx\n to a pointer to a Sxp object of type \nS\n.\n\n\nsexp(x)\n performs a default conversion.\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nCreate a \nCharSxp\n from a String.\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nWrap a callable Julia object \nf\n an a R \nClosSxpPtr\n.\n\n\nConstructs the following R code\n\n\nfunction(...) .External(juliaCallback, fExPtr, ...)\n\n\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nWrap a Julia object an a R \nExtPtrSxpPtr\n.\n\n\nWe store the pointer and the object in a const Dict to prevent it being removed by the Julia GC.\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nCreate a \nStrSxp\n from an \nAbstractString\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nCreate a \nStrSxp\n from an \nSymbol\n\n\n#\n\n\nRCall.sexp\n \n \nMethod\n.\n\n\nCreate a \nSymSxp\n from a \nSymbol\n\n\n#\n\n\nRCall.sexp_arglist_dots\n \n \nMethod\n.\n\n\nCreate an argument list for an R function call, with a varargs \"dots\" at the end.\n\n\n#\n\n\nRCall.sexpnum\n \n \nMethod\n.\n\n\nThe SEXPTYPE number of a \nSxp\n\n\nDetermined from the trailing 5 bits of the first 32-bit word. Is a 0-based index into the \ninfo\n field of a \nSxpHead\n.\n\n\n#\n\n\nRCall.tryEval\n \n \nMethod\n.\n\n\nA pure julia wrapper of R_tryEval.\n\n\n#\n\n\nRCall.unprotect\n \n \nMethod\n.\n\n\nRelease last \nn\n objects gc-protected by \nprotect\n.\n\n\n#\n\n\nRCall.unsafe_array\n \n \nMethod\n.\n\n\nThe same as \nunsafe_vec\n, except returns an appropriately sized array.\n\n\n#\n\n\nRCall.unsafe_vec\n \n \nMethod\n.\n\n\nRepresent the contents of a VectorSxp type as a \nVector\n.\n\n\nThis does \nnot\n copy the contents.  If the argument is not named (in R) or otherwise protected from R's garbage collection (e.g. by keeping the containing RObject in scope) the contents of this vector can be modified or could cause a memory error when accessed.\n\n\nThe contents are as stored in R.  Missing values (NA's) are represented in R by sentinels.  Missing data values in RealSxp and CplxSxp show up as \nNaN\n and \nNaN + NaNim\n, respectively.  Missing data in IntSxp show up as \n-2147483648\n, the minimum 32-bit integer value.  Internally a \nLglSxp\n is represented as \nVector{Int32}\n.  The convention is that \n0\n is \nfalse\n, \n-2147483648\n is \nNA\n and all other values represent \ntrue\n.\n\n\n\n\nMacros\n\n\n#\n\n\nRCall.@R_str\n \n \nMacro\n.\n\n\nR\n...\n\n\n\n\n\nAn inline R expression, the result of which is evaluated and returned as an \nRObject\n.\n\n\nIt supports substitution of Julia variables and expressions via prefix with \n$\n whenever not valid R syntax (i.e. when not immediately following another completed R expression):\n\n\nR\nglm(Sepal.Length ~ Sepal.Width, data=$iris)\n\n\n\n\n\nIt is also possible to pass Julia expressions:\n\n\nR\nplot((anonymous function))\n\n\n\n\n\nAll such Julia expressions are evaluated once, before the R expression is evaluated.\n\n\nThe expression does not support assigning to Julia variables, so the only way retrieve values from R via the return value.\n\n\n#\n\n\nRCall.@rget\n \n \nMacro\n.\n\n\nCopies variables from R to Julia using the same name.\n\n\n#\n\n\nRCall.@rimport\n \n \nMacro\n.\n\n\nImport an R Package as a Julia module. You can also use classic Python syntax to make an alias: \n@rimport *module-name* as *shorthand*\n\n\n#\n\n\nRCall.@rlibrary\n \n \nMacro\n.\n\n\nLoad all exported functions/objects of a R package to the current module.\n\n\n#\n\n\nRCall.@rput\n \n \nMacro\n.\n\n\nCopies variables from Julia to R using the same name.\n\n\n#\n\n\nRCall.@var_str\n \n \nMacro\n.\n\n\nReturns a variable named \"str\". Useful for passing keyword arguments containing dots.\n\n\n\n\nConstants\n\n\n#\n\n\nRCall.globalEnv\n \n \nConstant\n.\n\n\nR global Environment.\n\n\nglobalEnv[:x] = 1\nglobalEnv[:x]\n\n\n\n\n#\n\n\nRCall.jtypExtPtrs\n \n \nConstant\n.\n\n\nJulia types (typically functions) which are wrapped in \nExtPtrSxpPtr\n are stored here to prevent garbage collection by Julia.\n\n\n#\n\n\nRCall.typs\n \n \nConstant\n.\n\n\nvector of R Sxp types", 
            "title": "Internal API"
        }, 
        {
            "location": "/internal/#internal-api", 
            "text": "", 
            "title": "Internal API"
        }, 
        {
            "location": "/internal/#types", 
            "text": "#  RCall.AnySxp     Type .  R \"any\" object  #  RCall.BcodeSxp     Type .  R byte code  #  RCall.BuiltinSxp     Type .  R built-in function  #  RCall.CharSxp     Type .  R character string  #  RCall.ClosSxp     Type .  R function closure  #  RCall.CplxSxp     Type .  R complex vector  #  RCall.DotSxp     Type .  R dot-dot-dot object  #  RCall.EnvSxp     Type .  R environment  #  RCall.ExprSxp     Type .  R expression vector  #  RCall.ExtPtrSxp     Type .  R external pointer  #  RCall.IntSxp     Type .  R integer vector  #  RCall.LangSxp     Type .  R function call  #  RCall.LglSxp     Type .  R logical vector  #  RCall.ListSxp     Type .  R pairs (cons) list cell  #  RCall.NilSxp     Type .  R NULL value  #  RCall.PromSxp     Type .  R promise  #  RCall.RObject     Type .  An  RObject  is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the  RObject  itself is finalized by Julia. The parameter is the type of the S-expression.  When called with a Julia object as an argument, a corresponding R object is constructed.  julia  RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia  RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia  RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3  #  RCall.RawSxp     Type .  R byte vector  #  RCall.RealSxp     Type .  R real vector  #  RCall.S4Sxp     Type .  R S4 object  #  RCall.SpecialSxp     Type .  R special function  #  RCall.StrSxp     Type .  R vector of character strings  #  RCall.Sxp     Type .  RCall.jl's type  Sxp  mirrors the R symbolic expression record  SEXPREC  in R API. These are represented by a pointer  SxpPtr  (which is called  SEXP  in R API).  #  RCall.SxpHead     Type .  R Sxp header: a pointer to this is used for unknown types.  #  RCall.SymSxp     Type .  R symbol  #  RCall.VecSxp     Type .  R list (i.e. Array{Any,1})  #  RCall.WeakRefSxp     Type .  R weak reference", 
            "title": "Types"
        }, 
        {
            "location": "/internal/#methods", 
            "text": "#  Base.eltype     Method .  Element types of R vectors.  #  Base.getindex     Method .  extract the value of symbol s in the environment e  #  Base.getindex     Method .  extract the i-th element of LangSxp l  #  Base.getindex     Method .  Indexing into  VectorSxp  types uses Julia indexing into the  vec  result, except for  StrSxp  and the  VectorListSxp  types, which must apply  sexp  to the  Ptr{Void}  obtained by indexing into the  vec  result.  #  Base.getindex     Method .  String indexing finds the first element with the matching name  #  Base.isascii     Method .  Determines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).  * 0x00_0002_00 (bit 1): set of bytes (no known encoding)  * 0x00_0004_00 (bit 2): Latin-1  * 0x00_0008_00 (bit 3): UTF-8  * 0x00_0040_00 (bit 6): ASCII  We only support ASCII and UTF-8.  #  Base.length     Method .  Sxp methods for  length  return the R length.  Rf_xlength  handles Sxps that are not vector-like and R's \"long vectors\", which have a negative value for the  length  member.  #  Base.names     Method .  Returns the names of an R vector, the result is converted to a Julia symbol array.  #  Base.setindex!     Method .  assign value v to symbol s in the environment e  #  Base.setindex!     Method .  assign value v to the i-th element of LangSxp l  #  RCall.anyna     Method .  Check if there are any NA values in the vector.  #  RCall.bound     Method .  The R NAMED property, represented by 2 bits in the info field. This can take values 0,1 or 2, corresponding to whether it is bound to 0,1 or 2 or more symbols. See http://cran.r-project.org/doc/manuals/r-patched/R-exts.html#Named-objects-and-copying  #  RCall.dataptr     Method .  Pointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.  #  RCall.decref_extptr     Method .  Called by the R finalizer.  #  RCall.endEmbeddedR     Method .  endEmbeddedR()  Close embedded R session.  #  RCall.event_callback     Method .  Event Callback: allows R to process Julia events when R is busy. For example, writing output to STDOUT while running an expensive R command.  #  RCall.findNamespace     Method .  find namespace by name of the namespace, it is not error tolerant.  #  RCall.getNamespace     Method .  get namespace by name of the namespace. It is safer to be used than findNamespace as it checks bound.  #  RCall.getParseErrorMsg     Method .  Get the R parser error msg for the previous parsing result.  #  RCall.getattrib     Method .  Return a particular attribute of an RObject  #  RCall.getclass     Method .  Returns the class of an R object.  #  RCall.getnames     Method .  Returns the names of an R vector.  #  RCall.ijulia_displayplots     Method .  Called after cell evaluation. Closes graphics device and displays files in notebook.  #  RCall.ijulia_setdevice     Method .  Set options for R plotting with IJulia.  The first argument should be a MIME object: currently supported are *  MIME(\"image/png\")  [default] *  MIME(\"image/svg+xml\")  The remaining arguments (keyword only) are passed to the appropriate R graphics device: see the relevant R help for details.  #  RCall.initEmbeddedR     Method .  initEmbeddedR()  This initializes an embedded R session. It should only be called when R is not already running (e.g. if Julia is running inside an R session)  #  RCall.isna     Method .  Check if values correspond to R's sentinel NA values.  #  RCall.isnull     Method .  Check if values correspond to R's NULL object.  #  RCall.julia_extptr_callback     Method .  The function called by R .External for Julia callbacks.  It receives a  ListSxpPtr  containing  - a pointer to the function itself ( ExtPtrSxpPtr )  - a pointer to the Julia function ( ExtPtrSxpPtr )  - any arguments (as  SxpPtr )  #  RCall.makeExternalPtr     Function .  Create an ExtPtrSxpPtr object  #  RCall.makeNativeSymbolRef     Method .  Register a function pointer as an R NativeSymbol.  This is completely undocumented, so may break: we technically are supposed to use R_registerRoutines, but this is  much  easier for just 1 function.  #  RCall.naeltype     Method .  NA element for each type  #  RCall.newEnvironment     Method .  newEnvironment([env])  Create a new environment which extends environment  env  ( globalEnv  by default).  #  RCall.parseVector     Function .  A pure julia wrapper of R_ParseVector  #  RCall.preserve     Method .  Prevent garbage collection of an R object. Object can be released via  release .  This is slower than  protect , as it requires searching an internal list, but more flexible.  #  RCall.protect     Method .  Stack-based protection of garbage collection of R objects. Objects are released via  unprotect . Returns the same pointer, allowing inline use.  This is faster than  preserve , but more restrictive. Really only useful inside functions.  #  RCall.rcall     Method .  Evaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.  #  RCall.rcopy     Method .  Evaluate and convert the result of a string as an R expression.  #  RCall.rcopy     Method .  rcopy  copies the contents of an R object into a corresponding canonical Julia type.  #  RCall.rcopy     Method .  rcopy(T,p)  converts a pointer  p  to a Sxp object to a native Julia object of type T.  rcopy(p)  performs a default conversion.  #  RCall.registerCFinalizerEx     Method .  Register finalizer to be called by the R GC.  #  RCall.release     Method .  Release object that has been gc protected by  preserve .  #  RCall.render     Method .  Render an inline R script, substituting invalid \":($(Expr(:incomplete, \"incomplete: invalid string syntax\")))  #  RCall.reval     Function .  Evaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.  #  RCall.reval_p     Method .  Evaluate an R expression array iteratively.  #  RCall.reval_p     Method .  Evaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning a Sxp pointer.  #  RCall.rlang     Method .  Create a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated  #  RCall.rlang_p     Method .  Create a function call from a list of arguments  #  RCall.rparse     Method .  Parse a string as an R expression, returning an RObject.  #  RCall.rparse_p     Method .  Parse a string as an R expression, returning a Sxp pointer.  #  RCall.rprint     Method .  Parse, evaluate and print the result of a string as an R expression.  #  RCall.rprint     Method .  Print the value of an Sxp using R's printing mechanism  #  RCall.setattrib!     Method .  Set a particular attribute of an RObject  #  RCall.setclass!     Method .  Set the class of an R object.  #  RCall.setnames!     Method .  Set the names of an R vector.  #  RCall.sexp     Method .  Create a  StrSxp  from an Abstract String Array  #  RCall.sexp     Method .  Convert a  UnknownSxpPtr  to an approptiate  SxpPtr .  #  RCall.sexp     Method .  sexp(S,x)  converts a Julia object  x  to a pointer to a Sxp object of type  S .  sexp(x)  performs a default conversion.  #  RCall.sexp     Method .  Create a  CharSxp  from a String.  #  RCall.sexp     Method .  Wrap a callable Julia object  f  an a R  ClosSxpPtr .  Constructs the following R code  function(...) .External(juliaCallback, fExPtr, ...)  #  RCall.sexp     Method .  Wrap a Julia object an a R  ExtPtrSxpPtr .  We store the pointer and the object in a const Dict to prevent it being removed by the Julia GC.  #  RCall.sexp     Method .  Create a  StrSxp  from an  AbstractString  #  RCall.sexp     Method .  Create a  StrSxp  from an  Symbol  #  RCall.sexp     Method .  Create a  SymSxp  from a  Symbol  #  RCall.sexp_arglist_dots     Method .  Create an argument list for an R function call, with a varargs \"dots\" at the end.  #  RCall.sexpnum     Method .  The SEXPTYPE number of a  Sxp  Determined from the trailing 5 bits of the first 32-bit word. Is a 0-based index into the  info  field of a  SxpHead .  #  RCall.tryEval     Method .  A pure julia wrapper of R_tryEval.  #  RCall.unprotect     Method .  Release last  n  objects gc-protected by  protect .  #  RCall.unsafe_array     Method .  The same as  unsafe_vec , except returns an appropriately sized array.  #  RCall.unsafe_vec     Method .  Represent the contents of a VectorSxp type as a  Vector .  This does  not  copy the contents.  If the argument is not named (in R) or otherwise protected from R's garbage collection (e.g. by keeping the containing RObject in scope) the contents of this vector can be modified or could cause a memory error when accessed.  The contents are as stored in R.  Missing values (NA's) are represented in R by sentinels.  Missing data values in RealSxp and CplxSxp show up as  NaN  and  NaN + NaNim , respectively.  Missing data in IntSxp show up as  -2147483648 , the minimum 32-bit integer value.  Internally a  LglSxp  is represented as  Vector{Int32} .  The convention is that  0  is  false ,  -2147483648  is  NA  and all other values represent  true .", 
            "title": "Methods"
        }, 
        {
            "location": "/internal/#macros", 
            "text": "#  RCall.@R_str     Macro .  R ...   An inline R expression, the result of which is evaluated and returned as an  RObject .  It supports substitution of Julia variables and expressions via prefix with  $  whenever not valid R syntax (i.e. when not immediately following another completed R expression):  R glm(Sepal.Length ~ Sepal.Width, data=$iris)   It is also possible to pass Julia expressions:  R plot((anonymous function))   All such Julia expressions are evaluated once, before the R expression is evaluated.  The expression does not support assigning to Julia variables, so the only way retrieve values from R via the return value.  #  RCall.@rget     Macro .  Copies variables from R to Julia using the same name.  #  RCall.@rimport     Macro .  Import an R Package as a Julia module. You can also use classic Python syntax to make an alias:  @rimport *module-name* as *shorthand*  #  RCall.@rlibrary     Macro .  Load all exported functions/objects of a R package to the current module.  #  RCall.@rput     Macro .  Copies variables from Julia to R using the same name.  #  RCall.@var_str     Macro .  Returns a variable named \"str\". Useful for passing keyword arguments containing dots.", 
            "title": "Macros"
        }, 
        {
            "location": "/internal/#constants", 
            "text": "#  RCall.globalEnv     Constant .  R global Environment.  globalEnv[:x] = 1\nglobalEnv[:x]  #  RCall.jtypExtPtrs     Constant .  Julia types (typically functions) which are wrapped in  ExtPtrSxpPtr  are stored here to prevent garbage collection by Julia.  #  RCall.typs     Constant .  vector of R Sxp types", 
            "title": "Constants"
        }
    ]
}