{
    "docs": [
        {
            "location": "/", 
            "text": "RCall.jl\n\n\nR\n is a language for statistical computing and graphics that has been around for couple of decades and it has one of the most impressive collections of scientific and statistical packages of any environment. Recently, the \nJulia\n language has become an attractive alternative because it provides the remarkable performance of a low-level language without sacrificing the readability and ease-of-use of high-level languages. However, Julia still lacks the depth and scale of the R package environment.\n\n\nThis package, \nRCall\n, facilitates communication between these two languages and allows the user to call R packages from within Julia, providing the best of both worlds. Additionally, this is a pure Julia package so it is portable and easy to use.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#rcalljl", 
            "text": "R  is a language for statistical computing and graphics that has been around for couple of decades and it has one of the most impressive collections of scientific and statistical packages of any environment. Recently, the  Julia  language has become an attractive alternative because it provides the remarkable performance of a low-level language without sacrificing the readability and ease-of-use of high-level languages. However, Julia still lacks the depth and scale of the R package environment.  This package,  RCall , facilitates communication between these two languages and allows the user to call R packages from within Julia, providing the best of both worlds. Additionally, this is a pure Julia package so it is portable and easy to use.", 
            "title": "RCall.jl"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing RCall.jl\n\n\nRCall.jl requires that a recent version of R, at least 3.2.0, be installed. \n\n\n\n\nStandard installations\n\n\nIf R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with\n\n\nPkg.add(\nRCall\n)\n\n\n\n\nShould you experience problems with any of these methods, please \nopen an issue\n.\n\n\n\n\nWindows\n\n\nThe current \nWindows binary from CRAN\n.\n\n\n\n\nOS X\n\n\nThe \nCRAN .pkg\n or the \nhomebrew/science\n tap.\n\n\n\n\nLinux\n\n\nMost Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from \nCRAN\n.\n\n\n\n\nUbuntu\n\n\nThe following will update R on recent versions of Ubuntu:\n\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y \ndeb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/\n\nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev\n\n\n\n\n\n\nUpdating R\n\n\nIf you have updated the R installation, you may need to rebuild the RCall cache via\n\n\nBase.compilecache(\nRCall\n)\n\n\n\n\n\n\nOther methods\n\n\nIf you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).\n\n\nFirstly, try setting the \nR_HOME\n environmental variable to the location of your R installation, which can be found by running \nR.home()\n from within R. This can be set in your \n~/.juliarc.jl\n file via the \nENV\n global variable, e.g.\n\n\nENV[\nR_HOME\n] = ...\n\n\n\n\n\n\nWindows PATH\n\n\nThe \nPATH\n environmental variable should contain the location of your R binary, and the \nHOME\n variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-rcalljl", 
            "text": "RCall.jl requires that a recent version of R, at least 3.2.0, be installed.", 
            "title": "Installing RCall.jl"
        }, 
        {
            "location": "/installation/#standard-installations", 
            "text": "If R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with  Pkg.add( RCall )  Should you experience problems with any of these methods, please  open an issue .", 
            "title": "Standard installations"
        }, 
        {
            "location": "/installation/#windows", 
            "text": "The current  Windows binary from CRAN .", 
            "title": "Windows"
        }, 
        {
            "location": "/installation/#os-x", 
            "text": "The  CRAN .pkg  or the  homebrew/science  tap.", 
            "title": "OS X"
        }, 
        {
            "location": "/installation/#linux", 
            "text": "Most Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from  CRAN .", 
            "title": "Linux"
        }, 
        {
            "location": "/installation/#ubuntu", 
            "text": "The following will update R on recent versions of Ubuntu:  sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y  deb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/ \nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/installation/#updating-r", 
            "text": "If you have updated the R installation, you may need to rebuild the RCall cache via  Base.compilecache( RCall )", 
            "title": "Updating R"
        }, 
        {
            "location": "/installation/#other-methods", 
            "text": "If you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).  Firstly, try setting the  R_HOME  environmental variable to the location of your R installation, which can be found by running  R.home()  from within R. This can be set in your  ~/.juliarc.jl  file via the  ENV  global variable, e.g.  ENV[ R_HOME ] = ...", 
            "title": "Other methods"
        }, 
        {
            "location": "/installation/#windows-path", 
            "text": "The  PATH  environmental variable should contain the location of your R binary, and the  HOME  variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Windows PATH"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "Getting started\n\n\nThe RCall package is loaded via\n\n\njulia\n using RCall\n\n\n\n\nThis will initialize the R process in the background.\n\n\n\n\nR\"\"\n string macro and \nrcopy\n\n\nThe simplest way to use RCall is via the \nR\"\"\n string macro:\n\n\njulia\n x = R\nrnorm(10)\n\nRCall.RObject{RCall.RealSxp}\n [1]  2.14715927 -1.54768482 -2.15976616 -0.60222806  0.53387481 -1.00477140\n [7]  1.59695873 -0.05140429  0.87452673  0.64201625\nR\n\n\n\n\n\nThis evaluates the expression inside the string, and returns the result as an \nRObject\n, which is a Julia wrapper around an R object. This can be converted to a native Julia object via \nrcopy\n:\n\n\njulia\n rcopy(x)\n10-element Array{Float64,1}:\n  2.14716  \n -1.54768  \n -2.15977  \n -0.602228 \n  0.533875 \n -1.00477  \n  1.59696  \n -0.0514043\n  0.874527 \n  0.642016 \n\n\n\n\nR's \ndata.frame\n objects are automatically converted to Julia \nDataFrame\ns:\n\n\njulia\n iris = rcopy(R\niris\n)\n150x5 DataFrames.DataFrame\n\u2502 Row \u2502 Sepal.Length \u2502 Sepal.Width \u2502 Petal.Length \u2502 Petal.Width \u2502 Species     \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 1   \u2502 5.1          \u2502 3.5         \u2502 1.4          \u2502 0.2         \u2502 \nsetosa\n    \u2502\n\u2502 2   \u2502 4.9          \u2502 3.0         \u2502 1.4          \u2502 0.2         \u2502 \nsetosa\n    \u2502\n\u2502 3   \u2502 4.7          \u2502 3.2         \u2502 1.3          \u2502 0.2         \u2502 \nsetosa\n    \u2502\n...\n\n\n\n\nThe \nR\"\"\n macro also supports substitution of Julia objects via the \n$\n symbol, whenever it is not valid R syntax (i.e. when not directly following a symbol such as \naa$bb\n):\n\n\njulia\n R\nlm(Sepal.Length ~ Sepal.Width + Species, data=$iris)\n\nRCall.RObject{RCall.VecSxp}\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width + Species, data = `##RCall##1`)\n\nCoefficients:\n      (Intercept)        Sepal.Width  Speciesversicolor   Speciesvirginica  \n           2.2514             0.8036             1.4587             1.9468", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#getting-started", 
            "text": "The RCall package is loaded via  julia  using RCall  This will initialize the R process in the background.", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#r-string-macro-and-rcopy", 
            "text": "The simplest way to use RCall is via the  R\"\"  string macro:  julia  x = R rnorm(10) \nRCall.RObject{RCall.RealSxp}\n [1]  2.14715927 -1.54768482 -2.15976616 -0.60222806  0.53387481 -1.00477140\n [7]  1.59695873 -0.05140429  0.87452673  0.64201625\nR   This evaluates the expression inside the string, and returns the result as an  RObject , which is a Julia wrapper around an R object. This can be converted to a native Julia object via  rcopy :  julia  rcopy(x)\n10-element Array{Float64,1}:\n  2.14716  \n -1.54768  \n -2.15977  \n -0.602228 \n  0.533875 \n -1.00477  \n  1.59696  \n -0.0514043\n  0.874527 \n  0.642016   R's  data.frame  objects are automatically converted to Julia  DataFrame s:  julia  iris = rcopy(R iris )\n150x5 DataFrames.DataFrame\n\u2502 Row \u2502 Sepal.Length \u2502 Sepal.Width \u2502 Petal.Length \u2502 Petal.Width \u2502 Species     \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 1   \u2502 5.1          \u2502 3.5         \u2502 1.4          \u2502 0.2         \u2502  setosa     \u2502\n\u2502 2   \u2502 4.9          \u2502 3.0         \u2502 1.4          \u2502 0.2         \u2502  setosa     \u2502\n\u2502 3   \u2502 4.7          \u2502 3.2         \u2502 1.3          \u2502 0.2         \u2502  setosa     \u2502\n...  The  R\"\"  macro also supports substitution of Julia objects via the  $  symbol, whenever it is not valid R syntax (i.e. when not directly following a symbol such as  aa$bb ):  julia  R lm(Sepal.Length ~ Sepal.Width + Species, data=$iris) \nRCall.RObject{RCall.VecSxp}\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width + Species, data = `##RCall##1`)\n\nCoefficients:\n      (Intercept)        Sepal.Width  Speciesversicolor   Speciesvirginica  \n           2.2514             0.8036             1.4587             1.9468", 
            "title": "R\"\" string macro and rcopy"
        }, 
        {
            "location": "/public/", 
            "text": "Public API\n\n\n\n\nTypes\n\n\n#\n\n\nRCall.AnySxp\n \n \nType\n.\n\n\n\n\nR \"any\" object\n\n\nsource\n\n\n#\n\n\nRCall.BcodeSxp\n \n \nType\n.\n\n\n\n\nR byte code\n\n\nsource\n\n\n#\n\n\nRCall.BuiltinSxp\n \n \nType\n.\n\n\n\n\nR built-in function\n\n\nsource\n\n\n#\n\n\nRCall.CharSxp\n \n \nType\n.\n\n\n\n\nR character string\n\n\nsource\n\n\n#\n\n\nRCall.ClosSxp\n \n \nType\n.\n\n\n\n\nR function closure\n\n\nsource\n\n\n#\n\n\nRCall.CplxSxp\n \n \nType\n.\n\n\n\n\nR complex vector\n\n\nsource\n\n\n#\n\n\nRCall.DotSxp\n \n \nType\n.\n\n\n\n\nR dot-dot-dot object\n\n\nsource\n\n\n#\n\n\nRCall.EnvSxp\n \n \nType\n.\n\n\n\n\nR environment\n\n\nsource\n\n\n#\n\n\nRCall.ExprSxp\n \n \nType\n.\n\n\n\n\nR expression vector\n\n\nsource\n\n\n#\n\n\nRCall.ExtPtrSxp\n \n \nType\n.\n\n\n\n\nR external pointer\n\n\nsource\n\n\n#\n\n\nRCall.IntSxp\n \n \nType\n.\n\n\n\n\nR integer vector\n\n\nsource\n\n\n#\n\n\nRCall.LangSxp\n \n \nType\n.\n\n\n\n\nR function call\n\n\nsource\n\n\n#\n\n\nRCall.LglSxp\n \n \nType\n.\n\n\n\n\nR logical vector\n\n\nsource\n\n\n#\n\n\nRCall.ListSxp\n \n \nType\n.\n\n\n\n\nR pairs (cons) list cell\n\n\nsource\n\n\n#\n\n\nRCall.NilSxp\n \n \nType\n.\n\n\n\n\nR NULL value\n\n\nsource\n\n\n#\n\n\nRCall.PromSxp\n \n \nType\n.\n\n\n\n\nR promise\n\n\nsource\n\n\n#\n\n\nRCall.RObject\n \n \nType\n.\n\n\n\n\nAn \nRObject\n is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the \nRObject\n itself is finalized by Julia. The parameter is the type of the S-expression.\n\n\nWhen called with a Julia object as an argument, a corresponding R object is constructed.\n\n\njulia\n RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia\n RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia\n RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3\n\n\n\n\nsource\n\n\n#\n\n\nRCall.RawSxp\n \n \nType\n.\n\n\n\n\nR byte vector\n\n\nsource\n\n\n#\n\n\nRCall.RealSxp\n \n \nType\n.\n\n\n\n\nR real vector\n\n\nsource\n\n\n#\n\n\nRCall.S4Sxp\n \n \nType\n.\n\n\n\n\nR S4 object\n\n\nsource\n\n\n#\n\n\nRCall.SpecialSxp\n \n \nType\n.\n\n\n\n\nR special function\n\n\nsource\n\n\n#\n\n\nRCall.StrSxp\n \n \nType\n.\n\n\n\n\nR vector of character strings\n\n\nsource\n\n\n#\n\n\nRCall.Sxp\n \n \nType\n.\n\n\n\n\nR symbolic expression (\nSxpPtr\n): these are represented by a pointer to a symbolic expression record (\nSxp\n).\n\n\nsource\n\n\n#\n\n\nRCall.SxpHead\n \n \nType\n.\n\n\n\n\nR Sxp header: a pointer to this is used for unknown types.\n\n\nsource\n\n\n#\n\n\nRCall.SymSxp\n \n \nType\n.\n\n\n\n\nR symbol\n\n\nsource\n\n\n#\n\n\nRCall.VecSxp\n \n \nType\n.\n\n\n\n\nR list (i.e. Array{Any,1})\n\n\nsource\n\n\n#\n\n\nRCall.WeakRefSxp\n \n \nType\n.\n\n\n\n\nR weak reference\n\n\nsource\n\n\n\n\nMethods\n\n\n#\n\n\nBase.eltype\n \n \nFunction\n.\n\n\n\n\nElement types of R vectors.\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nFunction\n.\n\n\n\n\nIndexing into \nVectorSxp\n types uses Julia indexing into the \nvec\n result, except for \nStrSxp\n and the \nVectorListSxp\n types, which must apply \nsexp\n to the \nPtr{Void}\n obtained by indexing into the \nvec\n result.\n\n\nsource\n\n\nString indexing finds the first element with the matching name\n\n\nsource\n\n\nextract the i-th element of LangSxp l\n\n\nsource\n\n\nextract the value of symbol s in the environment e\n\n\nsource\n\n\n#\n\n\nBase.isascii\n \n \nFunction\n.\n\n\n\n\nDetermines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).  * 0x00_0002_00 (bit 1): set of bytes (no known encoding)  * 0x00_0004_00 (bit 2): Latin-1  * 0x00_0008_00 (bit 3): UTF-8  * 0x00_0040_00 (bit 6): ASCII\n\n\nWe only support ASCII and UTF-8.\n\n\nsource\n\n\n#\n\n\nBase.length\n \n \nFunction\n.\n\n\n\n\nSxp methods for \nlength\n return the R length.\n\n\nRf_xlength\n handles Sxps that are not vector-like and R's \"long vectors\", which have a negative value for the \nlength\n member.\n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nFunction\n.\n\n\n\n\nassign value v to the i-th element of LangSxp l\n\n\nsource\n\n\nassign value v to symbol s in the environment e\n\n\nsource\n\n\n#\n\n\nRCall.NAel\n \n \nFunction\n.\n\n\n\n\nNA element for each type\n\n\nsource\n\n\n#\n\n\nRCall.anyNA\n \n \nFunction\n.\n\n\n\n\nCheck if there are any NA values in the vector.\n\n\nsource\n\n\n#\n\n\nRCall.bound\n \n \nFunction\n.\n\n\n\n\nThe R NAMED property, represented by 2 bits in the info field. This can take values 0,1 or 2, corresponding to whether it is bound to 0,1 or 2 or more symbols. See http://cran.r-project.org/doc/manuals/r-patched/R-exts.html#Named-objects-and-copying\n\n\nsource\n\n\n#\n\n\nRCall.callJuliaExtPtr\n \n \nFunction\n.\n\n\n\n\nThe function called by R .External for Julia callbacks.\n\n\nIt receives a \nListSxpPtr\n containing  - a pointer to the function itself (\nExtPtrSxpPtr\n)  - a pointer to the Julia function (\nExtPtrSxpPtr\n)  - any arguments (as \nSxpPtr\n)\n\n\nsource\n\n\n#\n\n\nRCall.dataptr\n \n \nFunction\n.\n\n\n\n\nPointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.\n\n\nsource\n\n\n#\n\n\nRCall.decrefExtPtr\n \n \nFunction\n.\n\n\n\n\nCalled by the R finalizer.\n\n\nsource\n\n\n#\n\n\nRCall.endEmbeddedR\n \n \nFunction\n.\n\n\n\n\nendEmbeddedR()\n\n\n\n\nClose embedded R session.\n\n\nsource\n\n\n#\n\n\nRCall.findNamespace\n \n \nFunction\n.\n\n\n\n\nfind namespace by name of the namespace, it is not error tolerant.\n\n\nsource\n\n\n#\n\n\nRCall.getAttrib\n \n \nFunction\n.\n\n\n\n\nReturn a particular attribute of an RObject\n\n\nsource\n\n\n#\n\n\nRCall.getClass\n \n \nFunction\n.\n\n\n\n\nReturns the class of an R object.\n\n\nsource\n\n\n#\n\n\nRCall.getNames\n \n \nFunction\n.\n\n\n\n\nReturns the names of an R vector.\n\n\nsource\n\n\n#\n\n\nRCall.getNamespace\n \n \nFunction\n.\n\n\n\n\nget namespace by name of the namespace. It is safer to be used than findNamespace as it checks bound.\n\n\nsource\n\n\n#\n\n\nRCall.ijulia_displayplots\n \n \nFunction\n.\n\n\n\n\nCalled after cell evaluation. Closes graphics device and displays files in notebook.\n\n\nsource\n\n\n#\n\n\nRCall.ijulia_setdevice\n \n \nFunction\n.\n\n\n\n\nSet options for R plotting with IJulia.\n\n\nThe first argument should be a MIME object: currently supported are * \nMIME(\"image/png\")\n [default] * \nMIME(\"image/svg+xml\")\n\n\nThe remaining arguments (keyword only) are passed to the appropriate R graphics device: see the relevant R help for details.\n\n\nsource\n\n\n#\n\n\nRCall.initEmbeddedR\n \n \nFunction\n.\n\n\n\n\ninitEmbeddedR()\n\n\n\n\nThis initializes an embedded R session. It should only be called when R is not already running (e.g. if Julia is running inside an R session)\n\n\nsource\n\n\n#\n\n\nRCall.isFactor\n \n \nFunction\n.\n\n\n\n\nCheck whether an R variable is a factor variable\n\n\nsource\n\n\n#\n\n\nRCall.isNA\n \n \nFunction\n.\n\n\n\n\nCheck if values correspond to R's sentinel NA values.\n\n\nsource\n\n\n#\n\n\nRCall.isOrdered\n \n \nFunction\n.\n\n\n\n\nCheck whether an R variable is an ordered factor variable\n\n\nsource\n\n\n#\n\n\nRCall.makeExternalPtr\n \n \nFunction\n.\n\n\n\n\nCreate an ExtPtrSxpPtr object\n\n\nsource\n\n\n#\n\n\nRCall.makeNativeSymbol\n \n \nFunction\n.\n\n\n\n\nRegister a function pointer as an R NativeSymbol.\n\n\nThis is completely undocumented, so may break: we technically are supposed to use R_registerRoutines, but this is \nmuch\n easier for just 1 function.\n\n\nsource\n\n\n#\n\n\nRCall.newEnvironment\n \n \nFunction\n.\n\n\n\n\nnewEnvironment([env])\n\n\n\n\nCreate a new environment which extends environment \nenv\n (\nglobalEnv\n by default).\n\n\nsource\n\n\n#\n\n\nRCall.preserve\n \n \nFunction\n.\n\n\n\n\nPrevent garbage collection of an R object. Object can be released via \nrelease\n.\n\n\nThis is slower than \nprotect\n, as it requires searching an internal list, but more flexible.\n\n\nsource\n\n\n#\n\n\nRCall.protect\n \n \nFunction\n.\n\n\n\n\nStack-based protection of garbage collection of R objects. Objects are released via \nunprotect\n. Returns the same pointer, allowing inline use.\n\n\nThis is faster than \npreserve\n, but more restrictive. Really only useful inside functions.\n\n\nsource\n\n\n#\n\n\nRCall.rcall\n \n \nFunction\n.\n\n\n\n\nEvaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.\n\n\nsource\n\n\n#\n\n\nRCall.rcopy\n \n \nFunction\n.\n\n\n\n\nrcopy(T,p)\n converts a pointer \np\n to a Sxp object to a native Julia object of type T.\n\n\nrcopy(p)\n performs a default conversion.\n\n\nsource\n\n\nrcopy\n copies the contents of an R object into a corresponding canonical Julia type.\n\n\nsource\n\n\nEvaluate and convert the result of a string as an R expression.\n\n\nsource\n\n\n#\n\n\nRCall.registerFinalizer\n \n \nFunction\n.\n\n\n\n\nRegister finalizer to be called by the R GC.\n\n\nsource\n\n\n#\n\n\nRCall.release\n \n \nFunction\n.\n\n\n\n\nRelease object that has been gc protected by \npreserve\n.\n\n\nsource\n\n\n#\n\n\nRCall.reval\n \n \nFunction\n.\n\n\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.\n\n\nsource\n\n\n#\n\n\nRCall.reval_p\n \n \nFunction\n.\n\n\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning a Sxp pointer.\n\n\nsource\n\n\n#\n\n\nRCall.rlang\n \n \nFunction\n.\n\n\n\n\nCreate a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated\n\n\nsource\n\n\n#\n\n\nRCall.rlang_p\n \n \nFunction\n.\n\n\n\n\nCreate a function call from a list of arguments\n\n\nsource\n\n\n#\n\n\nRCall.rparse\n \n \nFunction\n.\n\n\n\n\nParse a string as an R expression, returning an RObject.\n\n\nsource\n\n\n#\n\n\nRCall.rparse_p\n \n \nFunction\n.\n\n\n\n\nParse a string as an R expression, returning a Sxp pointer.\n\n\nsource\n\n\n#\n\n\nRCall.rprint\n \n \nFunction\n.\n\n\n\n\nPrint the value of an Sxp using R's printing mechanism\n\n\nsource\n\n\nParse, evaluate and print the result of a string as an R expression.\n\n\nsource\n\n\n#\n\n\nRCall.rscript\n \n \nFunction\n.\n\n\n\n\nParses an inline R script, substituting invalid \":($(Expr(:incomplete, \"incomplete: invalid string syntax\")))\n\n\nsource\n\n\n#\n\n\nRCall.setAttrib!\n \n \nFunction\n.\n\n\n\n\nSet a particular attribute of an RObject\n\n\nsource\n\n\n#\n\n\nRCall.setClass!\n \n \nFunction\n.\n\n\n\n\nSet the class of an R object.\n\n\nsource\n\n\n#\n\n\nRCall.setNames!\n \n \nFunction\n.\n\n\n\n\nSet the names of an R vector.\n\n\nsource\n\n\n#\n\n\nRCall.sexp\n \n \nFunction\n.\n\n\n\n\nConvert a \nUnknownSxpPtr\n to an approptiate \nSxpPtr\n.\n\n\nsource\n\n\nsexp(S,x)\n converts a Julia object \nx\n to a pointer to a Sxp object of type \nS\n.\n\n\nsexp(x)\n performs a default conversion.\n\n\nsource\n\n\nCreate a \nSymSxp\n from a \nSymbol\n\n\nsource\n\n\nGeneric function for constructing Sxps from Julia objects.\n\n\nsource\n\n\nCreate a \nCharSxp\n from a String.\n\n\nsource\n\n\nCreate a \nStrSxp\n from an \nAbstractString\n\n\nsource\n\n\nWrap a Julia object an a R \nExtPtrSxpPtr\n.\n\n\nWe store the pointer and the object in a const Dict to prevent it being removed by the Julia GC.\n\n\nsource\n\n\nWrap a callable Julia object \nf\n an a R \nClosSxpPtr\n.\n\n\nConstructs the following R code\n\n\nfunction(...) .External(juliaCallback, fExPtr, ...)\n\n\n\n\nsource\n\n\n#\n\n\nRCall.sexp_arglist_dots\n \n \nFunction\n.\n\n\n\n\nCreate an argument list for an R function call, with a varargs \"dots\" at the end.\n\n\nsource\n\n\n#\n\n\nRCall.sexpnum\n \n \nFunction\n.\n\n\n\n\nThe SEXPTYPE number of a \nSxp\n\n\nDetermined from the trailing 5 bits of the first 32-bit word. Is a 0-based index into the \ninfo\n field of a \nSxpHead\n.\n\n\nsource\n\n\n#\n\n\nRCall.unprotect\n \n \nFunction\n.\n\n\n\n\nRelease last \nn\n objects gc-protected by \nprotect\n.\n\n\nsource\n\n\n#\n\n\nRCall.unsafe_array\n \n \nFunction\n.\n\n\n\n\nThe same as \nunsafe_vec\n, except returns an appropriately sized array.\n\n\nsource\n\n\n#\n\n\nRCall.unsafe_vec\n \n \nFunction\n.\n\n\n\n\nRepresent the contents of a VectorSxp type as a \nVector\n.\n\n\nThis does \nnot\n copy the contents.  If the argument is not named (in R) or otherwise protected from R's garbage collection (e.g. by keeping the containing RObject in scope) the contents of this vector can be modified or could cause a memory error when accessed.\n\n\nThe contents are as stored in R.  Missing values (NA's) are represented in R by sentinels.  Missing data values in RealSxp and CplxSxp show up as \nNaN\n and \nNaN + NaNim\n, respectively.  Missing data in IntSxp show up as \n-2147483648\n, the minimum 32-bit integer value.  Internally a \nLglSxp\n is represented as \nVector{Int32}\n.  The convention is that \n0\n is \nfalse\n, \n-2147483648\n is \nNA\n and all other values represent \ntrue\n.\n\n\nsource\n\n\n\n\nMacros\n\n\n#\n\n\nRCall.@R_str\n \n \nMacro\n.\n\n\n\n\nR\n...\n\n\n\n\n\nAn inline R expression, the result of which is evaluated and returned as an \nRObject\n.\n\n\nIt supports substitution of Julia variables and expressions via prefix with \n$\n whenever not valid R syntax (i.e. when not immediately following another completed R expression):\n\n\nR\nglm(Sepal.Length ~ Sepal.Width, data=$iris)\n\n\n\n\n\nIt is also possible to pass Julia expressions:\n\n\nR\nplot(RCall.#20)\n\n\n\n\n\nAll such Julia expressions are evaluated once, before the R expression is evaluated.\n\n\nThe expression does not support assigning to Julia variables, so the only way retrieve values from R via the return value.\n\n\nThe R expression is evaluated each time in a new environment, so standard R variable assignments (\n=\n or \n-\n) will not persist between expressions, or even multiple calls of the same expression. In order to persist variables, you should use the the double-assignment operator (\n-\n), which assigns the variable to the global environment.\n\n\nsource\n\n\n#\n\n\nRCall.@rget\n \n \nMacro\n.\n\n\n\n\nCopies variables from R to Julia using the same name.\n\n\nsource\n\n\n#\n\n\nRCall.@rimport\n \n \nMacro\n.\n\n\n\n\nImport a R Package as a Julia module. You can also use classic Python syntax to make an alias: \n@rimport *module-name* as *shorthand*\n\n\nsource\n\n\n#\n\n\nRCall.@rlibrary\n \n \nMacro\n.\n\n\n\n\nLoad all exported functions/objects of a R package to the current module.\n\n\nsource\n\n\n#\n\n\nRCall.@rput\n \n \nMacro\n.\n\n\n\n\nCopies variables from Julia to R using the same name.\n\n\nsource\n\n\n#\n\n\nRCall.@var_str\n \n \nMacro\n.\n\n\n\n\nReturns a variable named \"str\". Useful for passing keyword arguments containing dots.\n\n\nsource\n\n\n\n\nConstants\n\n\n#\n\n\nRCall.globalEnv\n \n \nConstant\n.\n\n\n\n\nR global Environment.\n\n\nglobalEnv[:x] = 1\nglobalEnv[:x]\n\n\n\n\nsource\n\n\n#\n\n\nRCall.jtypExtPtrs\n \n \nConstant\n.\n\n\n\n\nJulia types (typically functions) which are wrapped in \nExtPtrSxpPtr\n are stored here to prevent garbage collection by Julia.\n\n\nsource\n\n\n#\n\n\nRCall.typs\n \n \nConstant\n.\n\n\n\n\nvector of R Sxp types\n\n\nsource", 
            "title": "Public API"
        }, 
        {
            "location": "/public/#public-api", 
            "text": "", 
            "title": "Public API"
        }, 
        {
            "location": "/public/#types", 
            "text": "#  RCall.AnySxp     Type .   R \"any\" object  source  #  RCall.BcodeSxp     Type .   R byte code  source  #  RCall.BuiltinSxp     Type .   R built-in function  source  #  RCall.CharSxp     Type .   R character string  source  #  RCall.ClosSxp     Type .   R function closure  source  #  RCall.CplxSxp     Type .   R complex vector  source  #  RCall.DotSxp     Type .   R dot-dot-dot object  source  #  RCall.EnvSxp     Type .   R environment  source  #  RCall.ExprSxp     Type .   R expression vector  source  #  RCall.ExtPtrSxp     Type .   R external pointer  source  #  RCall.IntSxp     Type .   R integer vector  source  #  RCall.LangSxp     Type .   R function call  source  #  RCall.LglSxp     Type .   R logical vector  source  #  RCall.ListSxp     Type .   R pairs (cons) list cell  source  #  RCall.NilSxp     Type .   R NULL value  source  #  RCall.PromSxp     Type .   R promise  source  #  RCall.RObject     Type .   An  RObject  is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the  RObject  itself is finalized by Julia. The parameter is the type of the S-expression.  When called with a Julia object as an argument, a corresponding R object is constructed.  julia  RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia  RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia  RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3  source  #  RCall.RawSxp     Type .   R byte vector  source  #  RCall.RealSxp     Type .   R real vector  source  #  RCall.S4Sxp     Type .   R S4 object  source  #  RCall.SpecialSxp     Type .   R special function  source  #  RCall.StrSxp     Type .   R vector of character strings  source  #  RCall.Sxp     Type .   R symbolic expression ( SxpPtr ): these are represented by a pointer to a symbolic expression record ( Sxp ).  source  #  RCall.SxpHead     Type .   R Sxp header: a pointer to this is used for unknown types.  source  #  RCall.SymSxp     Type .   R symbol  source  #  RCall.VecSxp     Type .   R list (i.e. Array{Any,1})  source  #  RCall.WeakRefSxp     Type .   R weak reference  source", 
            "title": "Types"
        }, 
        {
            "location": "/public/#methods", 
            "text": "#  Base.eltype     Function .   Element types of R vectors.  source  #  Base.getindex     Function .   Indexing into  VectorSxp  types uses Julia indexing into the  vec  result, except for  StrSxp  and the  VectorListSxp  types, which must apply  sexp  to the  Ptr{Void}  obtained by indexing into the  vec  result.  source  String indexing finds the first element with the matching name  source  extract the i-th element of LangSxp l  source  extract the value of symbol s in the environment e  source  #  Base.isascii     Function .   Determines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).  * 0x00_0002_00 (bit 1): set of bytes (no known encoding)  * 0x00_0004_00 (bit 2): Latin-1  * 0x00_0008_00 (bit 3): UTF-8  * 0x00_0040_00 (bit 6): ASCII  We only support ASCII and UTF-8.  source  #  Base.length     Function .   Sxp methods for  length  return the R length.  Rf_xlength  handles Sxps that are not vector-like and R's \"long vectors\", which have a negative value for the  length  member.  source  #  Base.setindex!     Function .   assign value v to the i-th element of LangSxp l  source  assign value v to symbol s in the environment e  source  #  RCall.NAel     Function .   NA element for each type  source  #  RCall.anyNA     Function .   Check if there are any NA values in the vector.  source  #  RCall.bound     Function .   The R NAMED property, represented by 2 bits in the info field. This can take values 0,1 or 2, corresponding to whether it is bound to 0,1 or 2 or more symbols. See http://cran.r-project.org/doc/manuals/r-patched/R-exts.html#Named-objects-and-copying  source  #  RCall.callJuliaExtPtr     Function .   The function called by R .External for Julia callbacks.  It receives a  ListSxpPtr  containing  - a pointer to the function itself ( ExtPtrSxpPtr )  - a pointer to the Julia function ( ExtPtrSxpPtr )  - any arguments (as  SxpPtr )  source  #  RCall.dataptr     Function .   Pointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.  source  #  RCall.decrefExtPtr     Function .   Called by the R finalizer.  source  #  RCall.endEmbeddedR     Function .   endEmbeddedR()  Close embedded R session.  source  #  RCall.findNamespace     Function .   find namespace by name of the namespace, it is not error tolerant.  source  #  RCall.getAttrib     Function .   Return a particular attribute of an RObject  source  #  RCall.getClass     Function .   Returns the class of an R object.  source  #  RCall.getNames     Function .   Returns the names of an R vector.  source  #  RCall.getNamespace     Function .   get namespace by name of the namespace. It is safer to be used than findNamespace as it checks bound.  source  #  RCall.ijulia_displayplots     Function .   Called after cell evaluation. Closes graphics device and displays files in notebook.  source  #  RCall.ijulia_setdevice     Function .   Set options for R plotting with IJulia.  The first argument should be a MIME object: currently supported are *  MIME(\"image/png\")  [default] *  MIME(\"image/svg+xml\")  The remaining arguments (keyword only) are passed to the appropriate R graphics device: see the relevant R help for details.  source  #  RCall.initEmbeddedR     Function .   initEmbeddedR()  This initializes an embedded R session. It should only be called when R is not already running (e.g. if Julia is running inside an R session)  source  #  RCall.isFactor     Function .   Check whether an R variable is a factor variable  source  #  RCall.isNA     Function .   Check if values correspond to R's sentinel NA values.  source  #  RCall.isOrdered     Function .   Check whether an R variable is an ordered factor variable  source  #  RCall.makeExternalPtr     Function .   Create an ExtPtrSxpPtr object  source  #  RCall.makeNativeSymbol     Function .   Register a function pointer as an R NativeSymbol.  This is completely undocumented, so may break: we technically are supposed to use R_registerRoutines, but this is  much  easier for just 1 function.  source  #  RCall.newEnvironment     Function .   newEnvironment([env])  Create a new environment which extends environment  env  ( globalEnv  by default).  source  #  RCall.preserve     Function .   Prevent garbage collection of an R object. Object can be released via  release .  This is slower than  protect , as it requires searching an internal list, but more flexible.  source  #  RCall.protect     Function .   Stack-based protection of garbage collection of R objects. Objects are released via  unprotect . Returns the same pointer, allowing inline use.  This is faster than  preserve , but more restrictive. Really only useful inside functions.  source  #  RCall.rcall     Function .   Evaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.  source  #  RCall.rcopy     Function .   rcopy(T,p)  converts a pointer  p  to a Sxp object to a native Julia object of type T.  rcopy(p)  performs a default conversion.  source  rcopy  copies the contents of an R object into a corresponding canonical Julia type.  source  Evaluate and convert the result of a string as an R expression.  source  #  RCall.registerFinalizer     Function .   Register finalizer to be called by the R GC.  source  #  RCall.release     Function .   Release object that has been gc protected by  preserve .  source  #  RCall.reval     Function .   Evaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.  source  #  RCall.reval_p     Function .   Evaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning a Sxp pointer.  source  #  RCall.rlang     Function .   Create a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated  source  #  RCall.rlang_p     Function .   Create a function call from a list of arguments  source  #  RCall.rparse     Function .   Parse a string as an R expression, returning an RObject.  source  #  RCall.rparse_p     Function .   Parse a string as an R expression, returning a Sxp pointer.  source  #  RCall.rprint     Function .   Print the value of an Sxp using R's printing mechanism  source  Parse, evaluate and print the result of a string as an R expression.  source  #  RCall.rscript     Function .   Parses an inline R script, substituting invalid \":($(Expr(:incomplete, \"incomplete: invalid string syntax\")))  source  #  RCall.setAttrib!     Function .   Set a particular attribute of an RObject  source  #  RCall.setClass!     Function .   Set the class of an R object.  source  #  RCall.setNames!     Function .   Set the names of an R vector.  source  #  RCall.sexp     Function .   Convert a  UnknownSxpPtr  to an approptiate  SxpPtr .  source  sexp(S,x)  converts a Julia object  x  to a pointer to a Sxp object of type  S .  sexp(x)  performs a default conversion.  source  Create a  SymSxp  from a  Symbol  source  Generic function for constructing Sxps from Julia objects.  source  Create a  CharSxp  from a String.  source  Create a  StrSxp  from an  AbstractString  source  Wrap a Julia object an a R  ExtPtrSxpPtr .  We store the pointer and the object in a const Dict to prevent it being removed by the Julia GC.  source  Wrap a callable Julia object  f  an a R  ClosSxpPtr .  Constructs the following R code  function(...) .External(juliaCallback, fExPtr, ...)  source  #  RCall.sexp_arglist_dots     Function .   Create an argument list for an R function call, with a varargs \"dots\" at the end.  source  #  RCall.sexpnum     Function .   The SEXPTYPE number of a  Sxp  Determined from the trailing 5 bits of the first 32-bit word. Is a 0-based index into the  info  field of a  SxpHead .  source  #  RCall.unprotect     Function .   Release last  n  objects gc-protected by  protect .  source  #  RCall.unsafe_array     Function .   The same as  unsafe_vec , except returns an appropriately sized array.  source  #  RCall.unsafe_vec     Function .   Represent the contents of a VectorSxp type as a  Vector .  This does  not  copy the contents.  If the argument is not named (in R) or otherwise protected from R's garbage collection (e.g. by keeping the containing RObject in scope) the contents of this vector can be modified or could cause a memory error when accessed.  The contents are as stored in R.  Missing values (NA's) are represented in R by sentinels.  Missing data values in RealSxp and CplxSxp show up as  NaN  and  NaN + NaNim , respectively.  Missing data in IntSxp show up as  -2147483648 , the minimum 32-bit integer value.  Internally a  LglSxp  is represented as  Vector{Int32} .  The convention is that  0  is  false ,  -2147483648  is  NA  and all other values represent  true .  source", 
            "title": "Methods"
        }, 
        {
            "location": "/public/#macros", 
            "text": "#  RCall.@R_str     Macro .   R ...   An inline R expression, the result of which is evaluated and returned as an  RObject .  It supports substitution of Julia variables and expressions via prefix with  $  whenever not valid R syntax (i.e. when not immediately following another completed R expression):  R glm(Sepal.Length ~ Sepal.Width, data=$iris)   It is also possible to pass Julia expressions:  R plot(RCall.#20)   All such Julia expressions are evaluated once, before the R expression is evaluated.  The expression does not support assigning to Julia variables, so the only way retrieve values from R via the return value.  The R expression is evaluated each time in a new environment, so standard R variable assignments ( =  or  - ) will not persist between expressions, or even multiple calls of the same expression. In order to persist variables, you should use the the double-assignment operator ( - ), which assigns the variable to the global environment.  source  #  RCall.@rget     Macro .   Copies variables from R to Julia using the same name.  source  #  RCall.@rimport     Macro .   Import a R Package as a Julia module. You can also use classic Python syntax to make an alias:  @rimport *module-name* as *shorthand*  source  #  RCall.@rlibrary     Macro .   Load all exported functions/objects of a R package to the current module.  source  #  RCall.@rput     Macro .   Copies variables from Julia to R using the same name.  source  #  RCall.@var_str     Macro .   Returns a variable named \"str\". Useful for passing keyword arguments containing dots.  source", 
            "title": "Macros"
        }, 
        {
            "location": "/public/#constants", 
            "text": "#  RCall.globalEnv     Constant .   R global Environment.  globalEnv[:x] = 1\nglobalEnv[:x]  source  #  RCall.jtypExtPtrs     Constant .   Julia types (typically functions) which are wrapped in  ExtPtrSxpPtr  are stored here to prevent garbage collection by Julia.  source  #  RCall.typs     Constant .   vector of R Sxp types  source", 
            "title": "Constants"
        }
    ]
}