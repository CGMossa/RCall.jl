{
    "docs": [
        {
            "location": "/", 
            "text": "RCall.jl\n\n\nR\n is a language for statistical computing and graphics that has been around for couple of decades and it has one of the most impressive collections of scientific and statistical packages of any environment. Recently, the \nJulia\n language has become an attractive alternative because it provides the remarkable performance of a low-level language without sacrificing the readability and ease-of-use of high-level languages. However, Julia still lacks the depth and scale of the R package environment.\n\n\nThis package, \nRCall\n, facilitates communication between these two languages and allows the user to call R packages from within Julia, providing the best of both worlds. Additionally, this is a pure Julia package so it is portable and easy to use.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#rcalljl", 
            "text": "R  is a language for statistical computing and graphics that has been around for couple of decades and it has one of the most impressive collections of scientific and statistical packages of any environment. Recently, the  Julia  language has become an attractive alternative because it provides the remarkable performance of a low-level language without sacrificing the readability and ease-of-use of high-level languages. However, Julia still lacks the depth and scale of the R package environment.  This package,  RCall , facilitates communication between these two languages and allows the user to call R packages from within Julia, providing the best of both worlds. Additionally, this is a pure Julia package so it is portable and easy to use.", 
            "title": "RCall.jl"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing RCall.jl\n\n\nRCall.jl requires that a recent version of R, at least 3.2.0, be installed. \n\n\n\n\nStandard installations\n\n\nIf R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with\n\n\nPkg.add(\nRCall\n)\n\n\n\n\nShould you experience problems with any of these methods, please \nopen an issue\n.\n\n\n\n\nWindows\n\n\nThe current \nWindows binary from CRAN\n.\n\n\n\n\nOS X\n\n\nThe \nCRAN .pkg\n or the \nhomebrew/science\n tap.\n\n\n\n\nLinux\n\n\nMost Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from \nCRAN\n.\n\n\n\n\nUbuntu\n\n\nThe following will update R on recent versions of Ubuntu:\n\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y \ndeb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/\n\nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev\n\n\n\n\n\n\nUpdating R\n\n\nIf you have updated the R installation, you may need to rebuild the RCall cache via\n\n\nBase.compilecache(\nRCall\n)\n\n\n\n\n\n\nOther methods\n\n\nIf you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).\n\n\nFirstly, try setting the \nR_HOME\n environmental variable to the location of your R installation, which can be found by running \nR.home()\n from within R. This can be set in your \n~/.juliarc.jl\n file via the \nENV\n global variable, e.g.\n\n\nENV[\nR_HOME\n] = ...\n\n\n\n\n\n\nWindows PATH\n\n\nThe \nPATH\n environmental variable should contain the location of your R binary, and the \nHOME\n variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-rcalljl", 
            "text": "RCall.jl requires that a recent version of R, at least 3.2.0, be installed.", 
            "title": "Installing RCall.jl"
        }, 
        {
            "location": "/installation/#standard-installations", 
            "text": "If R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with  Pkg.add( RCall )  Should you experience problems with any of these methods, please  open an issue .", 
            "title": "Standard installations"
        }, 
        {
            "location": "/installation/#windows", 
            "text": "The current  Windows binary from CRAN .", 
            "title": "Windows"
        }, 
        {
            "location": "/installation/#os-x", 
            "text": "The  CRAN .pkg  or the  homebrew/science  tap.", 
            "title": "OS X"
        }, 
        {
            "location": "/installation/#linux", 
            "text": "Most Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from  CRAN .", 
            "title": "Linux"
        }, 
        {
            "location": "/installation/#ubuntu", 
            "text": "The following will update R on recent versions of Ubuntu:  sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y  deb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/ \nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/installation/#updating-r", 
            "text": "If you have updated the R installation, you may need to rebuild the RCall cache via  Base.compilecache( RCall )", 
            "title": "Updating R"
        }, 
        {
            "location": "/installation/#other-methods", 
            "text": "If you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).  Firstly, try setting the  R_HOME  environmental variable to the location of your R installation, which can be found by running  R.home()  from within R. This can be set in your  ~/.juliarc.jl  file via the  ENV  global variable, e.g.  ENV[ R_HOME ] = ...", 
            "title": "Other methods"
        }, 
        {
            "location": "/installation/#windows-path", 
            "text": "The  PATH  environmental variable should contain the location of your R binary, and the  HOME  variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Windows PATH"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "Getting started\n\n\nThe RCall package is loaded via\n\n\njulia\n using RCall\n\n\n\n\nThis will initialize the R process in the background.\n\n\n\n\nR\"\"\n string macro and \nrcopy\n\n\nThe simplest way to use RCall is via the \nR\"\"\n string macro:\n\n\njulia\n x = R\nrnorm(10)\n\nRCall.RObject{RCall.RealSxp}\n [1]  2.14715927 -1.54768482 -2.15976616 -0.60222806  0.53387481 -1.00477140\n [7]  1.59695873 -0.05140429  0.87452673  0.64201625\nR\n\n\n\n\n\nThis evaluates the expression inside the string, and returns the result as an \nRObject\n, which is a Julia wrapper around an R object. This can be converted to a native Julia object via \nrcopy\n:\n\n\njulia\n rcopy(x)\n10-element Array{Float64,1}:\n  2.14716  \n -1.54768  \n -2.15977  \n -0.602228 \n  0.533875 \n -1.00477  \n  1.59696  \n -0.0514043\n  0.874527 \n  0.642016 \n\n\n\n\nR's \ndata.frame\n objects are automatically converted to Julia \nDataFrame\ns:\n\n\njulia\n iris = rcopy(R\niris\n)\n150x5 DataFrames.DataFrame\n\u2502 Row \u2502 Sepal.Length \u2502 Sepal.Width \u2502 Petal.Length \u2502 Petal.Width \u2502 Species     \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 1   \u2502 5.1          \u2502 3.5         \u2502 1.4          \u2502 0.2         \u2502 \nsetosa\n    \u2502\n\u2502 2   \u2502 4.9          \u2502 3.0         \u2502 1.4          \u2502 0.2         \u2502 \nsetosa\n    \u2502\n\u2502 3   \u2502 4.7          \u2502 3.2         \u2502 1.3          \u2502 0.2         \u2502 \nsetosa\n    \u2502\n...\n\n\n\n\nThe \nR\"\"\n macro also supports substitution of Julia objects via the \n$\n symbol, whenever it is not valid R syntax (i.e. when not directly following a symbol such as \naa$bb\n):\n\n\njulia\n R\nlm(Sepal.Length ~ Sepal.Width + Species, data=$iris)\n\nRCall.RObject{RCall.VecSxp}\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width + Species, data = `##RCall##1`)\n\nCoefficients:\n      (Intercept)        Sepal.Width  Speciesversicolor   Speciesvirginica  \n           2.2514             0.8036             1.4587             1.9468", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#getting-started", 
            "text": "The RCall package is loaded via  julia  using RCall  This will initialize the R process in the background.", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#r-string-macro-and-rcopy", 
            "text": "The simplest way to use RCall is via the  R\"\"  string macro:  julia  x = R rnorm(10) \nRCall.RObject{RCall.RealSxp}\n [1]  2.14715927 -1.54768482 -2.15976616 -0.60222806  0.53387481 -1.00477140\n [7]  1.59695873 -0.05140429  0.87452673  0.64201625\nR   This evaluates the expression inside the string, and returns the result as an  RObject , which is a Julia wrapper around an R object. This can be converted to a native Julia object via  rcopy :  julia  rcopy(x)\n10-element Array{Float64,1}:\n  2.14716  \n -1.54768  \n -2.15977  \n -0.602228 \n  0.533875 \n -1.00477  \n  1.59696  \n -0.0514043\n  0.874527 \n  0.642016   R's  data.frame  objects are automatically converted to Julia  DataFrame s:  julia  iris = rcopy(R iris )\n150x5 DataFrames.DataFrame\n\u2502 Row \u2502 Sepal.Length \u2502 Sepal.Width \u2502 Petal.Length \u2502 Petal.Width \u2502 Species     \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 1   \u2502 5.1          \u2502 3.5         \u2502 1.4          \u2502 0.2         \u2502  setosa     \u2502\n\u2502 2   \u2502 4.9          \u2502 3.0         \u2502 1.4          \u2502 0.2         \u2502  setosa     \u2502\n\u2502 3   \u2502 4.7          \u2502 3.2         \u2502 1.3          \u2502 0.2         \u2502  setosa     \u2502\n...  The  R\"\"  macro also supports substitution of Julia objects via the  $  symbol, whenever it is not valid R syntax (i.e. when not directly following a symbol such as  aa$bb ):  julia  R lm(Sepal.Length ~ Sepal.Width + Species, data=$iris) \nRCall.RObject{RCall.VecSxp}\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width + Species, data = `##RCall##1`)\n\nCoefficients:\n      (Intercept)        Sepal.Width  Speciesversicolor   Speciesvirginica  \n           2.2514             0.8036             1.4587             1.9468", 
            "title": "R\"\" string macro and rcopy"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\n\n\nTypes\n\n\n#\n\n\nRCall.RObject\n \n \nType\n.\n\n\n\n\nAn \nRObject\n is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the \nRObject\n itself is finalized by Julia. The parameter is the type of the S-expression.\n\n\nWhen called with a Julia object as an argument, a corresponding R object is constructed.\n\n\njulia\n RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia\n RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia\n RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3\n\n\n\n\nsource\n\n\n#\n\n\nRCall.Sxp\n \n \nType\n.\n\n\n\n\nR symbolic expression (\nSxpPtr\n): these are represented by a pointer to a symbolic expression record (\nSxp\n).\n\n\nsource\n\n\n#\n\n\nRCall.NilSxp\n \n \nType\n.\n\n\n\n\nR NULL value\n\n\nsource\n\n\n#\n\n\nRCall.StrSxp\n \n \nType\n.\n\n\n\n\nR vector of character strings\n\n\nsource\n\n\n#\n\n\nRCall.CharSxp\n \n \nType\n.\n\n\n\n\nR character string\n\n\nsource\n\n\n#\n\n\nRCall.LglSxp\n \n \nType\n.\n\n\n\n\nR logical vector\n\n\nsource\n\n\n#\n\n\nRCall.IntSxp\n \n \nType\n.\n\n\n\n\nR integer vector\n\n\nsource\n\n\n#\n\n\nRCall.RealSxp\n \n \nType\n.\n\n\n\n\nR real vector\n\n\nsource\n\n\n#\n\n\nRCall.CplxSxp\n \n \nType\n.\n\n\n\n\nR complex vector\n\n\nsource\n\n\n#\n\n\nRCall.ClosSxp\n \n \nType\n.\n\n\n\n\nR function closure\n\n\nsource\n\n\n\n\nMethods\n\n\n#\n\n\nRCall.getAttrib\n \n \nFunction\n.\n\n\n\n\nReturn a particular attribute of an RObject\n\n\nsource\n\n\n#\n\n\nRCall.setAttrib!\n \n \nFunction\n.\n\n\n\n\nSet a particular attribute of an RObject\n\n\nsource\n\n\n#\n\n\nRCall.getNames\n \n \nFunction\n.\n\n\n\n\nReturns the names of an R vector.\n\n\nsource\n\n\n#\n\n\nRCall.setNames!\n \n \nFunction\n.\n\n\n\n\nSet the names of an R vector.\n\n\nsource\n\n\n#\n\n\nRCall.rcopy\n \n \nFunction\n.\n\n\n\n\nrcopy(T,p)\n converts a pointer \np\n to a Sxp object to a native Julia object of type T.\n\n\nrcopy(p)\n performs a default conversion.\n\n\nsource\n\n\nrcopy\n copies the contents of an R object into a corresponding canonical Julia type.\n\n\nsource\n\n\nEvaluate and convert the result of a string as an R expression.\n\n\nsource\n\n\n#\n\n\nRCall.rparse\n \n \nFunction\n.\n\n\n\n\nParse a string as an R expression, returning an RObject.\n\n\nsource\n\n\n#\n\n\nRCall.rprint\n \n \nFunction\n.\n\n\n\n\nPrint the value of an Sxp using R's printing mechanism\n\n\nsource\n\n\nParse, evaluate and print the result of a string as an R expression.\n\n\nsource\n\n\n#\n\n\nRCall.reval\n \n \nFunction\n.\n\n\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.\n\n\nsource\n\n\n#\n\n\nRCall.rcall\n \n \nFunction\n.\n\n\n\n\nEvaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.\n\n\nsource\n\n\n#\n\n\nRCall.rlang\n \n \nFunction\n.\n\n\n\n\nCreate a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated\n\n\nsource\n\n\n#\n\n\nRCall.isNA\n \n \nFunction\n.\n\n\n\n\nCheck if values correspond to R's sentinel NA values.\n\n\nsource\n\n\n#\n\n\nRCall.anyNA\n \n \nFunction\n.\n\n\n\n\nCheck if there are any NA values in the vector.\n\n\nsource\n\n\n#\n\n\nRCall.isFactor\n \n \nFunction\n.\n\n\n\n\nCheck whether an R variable is a factor variable\n\n\nsource\n\n\n#\n\n\nRCall.isOrdered\n \n \nFunction\n.\n\n\n\n\nCheck whether an R variable is an ordered factor variable\n\n\nsource\n\n\n\n\nMacros\n\n\n#\n\n\nRCall.@rimport\n \n \nMacro\n.\n\n\n\n\nImport a R Package as a Julia module. You can also use classic Python syntax to make an alias: \n@rimport *module-name* as *shorthand*\n\n\nsource\n\n\n#\n\n\nRCall.@rlibrary\n \n \nMacro\n.\n\n\n\n\nLoad all exported functions/objects of a R package to the current module.\n\n\nsource\n\n\n#\n\n\nRCall.@rput\n \n \nMacro\n.\n\n\n\n\nCopies variables from Julia to R using the same name.\n\n\nsource\n\n\n#\n\n\nRCall.@rget\n \n \nMacro\n.\n\n\n\n\nCopies variables from R to Julia using the same name.\n\n\nsource\n\n\n#\n\n\nRCall.@var_str\n \n \nMacro\n.\n\n\n\n\nReturns a variable named \"str\". Useful for passing keyword arguments containing dots.\n\n\nsource\n\n\n#\n\n\nRCall.@R_str\n \n \nMacro\n.\n\n\n\n\nAllows inline R scripts, e.g\n\n\nfoo = R\nglm(Sepal.Length ~ Sepal.Width, data=$iris)\n\n\n\n\n\nDoes not yet support assigning to Julia variables, so can only return results.\n\n\nsource\n\n\n\n\nVariables\n\n\n#\n\n\nRCall.globalEnv\n \n \nConstant\n.\n\n\n\n\nR global Environment.\n\n\nglobalEnv[:x] = 1\nglobalEnv[:x]\n\n\n\n\nsource", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#types", 
            "text": "#  RCall.RObject     Type .   An  RObject  is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the  RObject  itself is finalized by Julia. The parameter is the type of the S-expression.  When called with a Julia object as an argument, a corresponding R object is constructed.  julia  RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia  RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia  RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3  source  #  RCall.Sxp     Type .   R symbolic expression ( SxpPtr ): these are represented by a pointer to a symbolic expression record ( Sxp ).  source  #  RCall.NilSxp     Type .   R NULL value  source  #  RCall.StrSxp     Type .   R vector of character strings  source  #  RCall.CharSxp     Type .   R character string  source  #  RCall.LglSxp     Type .   R logical vector  source  #  RCall.IntSxp     Type .   R integer vector  source  #  RCall.RealSxp     Type .   R real vector  source  #  RCall.CplxSxp     Type .   R complex vector  source  #  RCall.ClosSxp     Type .   R function closure  source", 
            "title": "Types"
        }, 
        {
            "location": "/lib/public/#methods", 
            "text": "#  RCall.getAttrib     Function .   Return a particular attribute of an RObject  source  #  RCall.setAttrib!     Function .   Set a particular attribute of an RObject  source  #  RCall.getNames     Function .   Returns the names of an R vector.  source  #  RCall.setNames!     Function .   Set the names of an R vector.  source  #  RCall.rcopy     Function .   rcopy(T,p)  converts a pointer  p  to a Sxp object to a native Julia object of type T.  rcopy(p)  performs a default conversion.  source  rcopy  copies the contents of an R object into a corresponding canonical Julia type.  source  Evaluate and convert the result of a string as an R expression.  source  #  RCall.rparse     Function .   Parse a string as an R expression, returning an RObject.  source  #  RCall.rprint     Function .   Print the value of an Sxp using R's printing mechanism  source  Parse, evaluate and print the result of a string as an R expression.  source  #  RCall.reval     Function .   Evaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.  source  #  RCall.rcall     Function .   Evaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.  source  #  RCall.rlang     Function .   Create a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated  source  #  RCall.isNA     Function .   Check if values correspond to R's sentinel NA values.  source  #  RCall.anyNA     Function .   Check if there are any NA values in the vector.  source  #  RCall.isFactor     Function .   Check whether an R variable is a factor variable  source  #  RCall.isOrdered     Function .   Check whether an R variable is an ordered factor variable  source", 
            "title": "Methods"
        }, 
        {
            "location": "/lib/public/#macros", 
            "text": "#  RCall.@rimport     Macro .   Import a R Package as a Julia module. You can also use classic Python syntax to make an alias:  @rimport *module-name* as *shorthand*  source  #  RCall.@rlibrary     Macro .   Load all exported functions/objects of a R package to the current module.  source  #  RCall.@rput     Macro .   Copies variables from Julia to R using the same name.  source  #  RCall.@rget     Macro .   Copies variables from R to Julia using the same name.  source  #  RCall.@var_str     Macro .   Returns a variable named \"str\". Useful for passing keyword arguments containing dots.  source  #  RCall.@R_str     Macro .   Allows inline R scripts, e.g  foo = R glm(Sepal.Length ~ Sepal.Width, data=$iris)   Does not yet support assigning to Julia variables, so can only return results.  source", 
            "title": "Macros"
        }, 
        {
            "location": "/lib/public/#variables", 
            "text": "#  RCall.globalEnv     Constant .   R global Environment.  globalEnv[:x] = 1\nglobalEnv[:x]  source", 
            "title": "Variables"
        }
    ]
}