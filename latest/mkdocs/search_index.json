{
    "docs": [
        {
            "location": "/", 
            "text": "RCall.jl\n\n\nR\n is a language for statistical computing and graphics that has been around for couple of decades and it has one of the most impressive collections of scientific and statistical packages of any environment. Recently, the \nJulia\n language has become an attractive alternative because it provides the remarkable performance of a low-level language without sacrificing the readability and ease-of-use of high-level languages. However, Julia still lacks the depth and scale of the R package environment.\n\n\nThis package, \nRCall\n, facilitates communication between these two languages and allows the user to call R packages from within Julia, providing the best of both worlds. Additionally, this is a pure Julia package so it is portable and easy to use.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#rcalljl", 
            "text": "R  is a language for statistical computing and graphics that has been around for couple of decades and it has one of the most impressive collections of scientific and statistical packages of any environment. Recently, the  Julia  language has become an attractive alternative because it provides the remarkable performance of a low-level language without sacrificing the readability and ease-of-use of high-level languages. However, Julia still lacks the depth and scale of the R package environment.  This package,  RCall , facilitates communication between these two languages and allows the user to call R packages from within Julia, providing the best of both worlds. Additionally, this is a pure Julia package so it is portable and easy to use.", 
            "title": "RCall.jl"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing RCall.jl\n\n\nRCall.jl requires that a recent version of R, at least 3.2.0, be installed. \n\n\n\n\nStandard installations\n\n\nIf R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with\n\n\nPkg.add(\nRCall\n)\n\n\n\n\nShould you experience problems with any of these methods, please \nopen an issue\n.\n\n\n\n\nWindows\n\n\nThe current \nWindows binary from CRAN\n.\n\n\n\n\nOS X\n\n\nThe \nCRAN .pkg\n or the \nhomebrew/science\n tap.\n\n\n\n\nLinux\n\n\nMost Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from \nCRAN\n.\n\n\n\n\nUbuntu\n\n\nThe following will update R on recent versions of Ubuntu:\n\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y \ndeb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/\n\nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev\n\n\n\n\n\n\nUpdating R\n\n\nIf you have updated the R installation, you may need to rebuild the RCall cache via\n\n\nBase.compilecache(\nRCall\n)\n\n\n\n\n\n\nOther methods\n\n\nIf you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).\n\n\nFirstly, try setting the \nR_HOME\n environmental variable to the location of your R installation, which can be found by running \nR.home()\n from within R. This can be set in your \n~/.juliarc.jl\n file via the \nENV\n global variable, e.g.\n\n\nENV[\nR_HOME\n] = ...\n\n\n\n\n\n\nWindows PATH\n\n\nThe \nPATH\n environmental variable should contain the location of your R binary, and the \nHOME\n variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-rcalljl", 
            "text": "RCall.jl requires that a recent version of R, at least 3.2.0, be installed.", 
            "title": "Installing RCall.jl"
        }, 
        {
            "location": "/installation/#standard-installations", 
            "text": "If R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with  Pkg.add( RCall )  Should you experience problems with any of these methods, please  open an issue .", 
            "title": "Standard installations"
        }, 
        {
            "location": "/installation/#windows", 
            "text": "The current  Windows binary from CRAN .", 
            "title": "Windows"
        }, 
        {
            "location": "/installation/#os-x", 
            "text": "The  CRAN .pkg  or the  homebrew/science  tap.", 
            "title": "OS X"
        }, 
        {
            "location": "/installation/#linux", 
            "text": "Most Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from  CRAN .", 
            "title": "Linux"
        }, 
        {
            "location": "/installation/#ubuntu", 
            "text": "The following will update R on recent versions of Ubuntu:  sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nsudo add-apt-repository -y  deb http://cran.rstudio.com/bin/linux/ubuntu $(lsb_release -s -c)/ \nsudo apt-get update -y\nsudo apt-get install -y r-base r-base-dev", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/installation/#updating-r", 
            "text": "If you have updated the R installation, you may need to rebuild the RCall cache via  Base.compilecache( RCall )", 
            "title": "Updating R"
        }, 
        {
            "location": "/installation/#other-methods", 
            "text": "If you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).  Firstly, try setting the  R_HOME  environmental variable to the location of your R installation, which can be found by running  R.home()  from within R. This can be set in your  ~/.juliarc.jl  file via the  ENV  global variable, e.g.  ENV[ R_HOME ] = ...", 
            "title": "Other methods"
        }, 
        {
            "location": "/installation/#windows-path", 
            "text": "The  PATH  environmental variable should contain the location of your R binary, and the  HOME  variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Windows PATH"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "Getting started\n\n\nThe RCall package is loaded via\n\n\njulia\n using RCall\n\n\n\n\nThis will initialize the R process in the background.\n\n\n\n\nR\"\"\n string macro\n\n\nThe simplest way to use RCall is via the \nR\"\"\n string macro:\n\n\njulia\n R\nrnorm(10)\n\nRCall.RObject{RCall.RealSxp}\n [1] -0.76109380 -1.88859819 -2.17300767 -2.13762687 -0.05306916 -0.76323287\n [7] -1.61554958 -1.70552718  0.41554723 -1.14047561\n\n\n\n\nThis evaluates the expression inside the string in R, and returns the result as an \nRObject\n, which is a Julia wrapper type around an R object.\n\n\nThe \nR\"\"\n string macro supports variable substitution of Julia objects via the \n$\n symbol, whenever it is not valid R syntax (i.e. when not directly following a symbol or completed expression such as \naa$bb\n):\n\n\njulia\n x = randn(10)\n10-element Array{Float64,1}:\n  0.743429\n -0.63004\n -1.2247\n -1.02392\n  0.122291\n -2.12829\n -0.564988\n  0.910239\n -1.38506\n -0.211791\n\njulia\n R\nt.test($x)\n\nRCall.RObject{RCall.VecSxp}\n\n    One Sample t-test\n\ndata:  $x\nt = -1.7817, df = 9, p-value = 0.1085\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n -1.2239875  0.1454214\nsample estimates:\n mean of x\n-0.5392831\n\n\n\n\nIt is also possible to pass Julia expressions which are evaluated before being passed to R: these should be included in parentheses\n\n\njulia\n R\noptim(0, $(x -\n x-cos(x)), method='BFGS')\n\nRCall.RObject{RCall.VecSxp}\n$par\n[1] -1.56343\n\n$value\n[1] -1.570796\n\n$counts\nfunction gradient\n      14       13\n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\n\n\nrcopy\n\n\nThe \nrcopy\n function converts \nRObject\ns to Julia objects. It uses a variety of heuristics to pick the most appropriate Julia type:\n\n\njulia\n rcopy(R\nc(1)\n)\n1.0\n\njulia\n rcopy(R\nc(1,2)\n)\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\njulia\n rcopy(R\nlist(1,'zz')\n)\n2-element Array{Any,1}:\n 1.0\n  \nzz\n\n\njulia\n rcopy(R\nlist(a=1,b='zz')\n)\nDict{Symbol,Any} with 2 entries:\n  :a =\n 1.0\n  :b =\n \nzz\n\n\n\n\n\nIt is possible to force a specific conversion by passing the output type as the first argument:\n\n\njulia\n rcopy(Array{Int},R\nc(1,2)\n)\n2-element Array{Int64,1}:\n 1\n 2", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#getting-started", 
            "text": "The RCall package is loaded via  julia  using RCall  This will initialize the R process in the background.", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#r-string-macro", 
            "text": "The simplest way to use RCall is via the  R\"\"  string macro:  julia  R rnorm(10) \nRCall.RObject{RCall.RealSxp}\n [1] -0.76109380 -1.88859819 -2.17300767 -2.13762687 -0.05306916 -0.76323287\n [7] -1.61554958 -1.70552718  0.41554723 -1.14047561  This evaluates the expression inside the string in R, and returns the result as an  RObject , which is a Julia wrapper type around an R object.  The  R\"\"  string macro supports variable substitution of Julia objects via the  $  symbol, whenever it is not valid R syntax (i.e. when not directly following a symbol or completed expression such as  aa$bb ):  julia  x = randn(10)\n10-element Array{Float64,1}:\n  0.743429\n -0.63004\n -1.2247\n -1.02392\n  0.122291\n -2.12829\n -0.564988\n  0.910239\n -1.38506\n -0.211791\n\njulia  R t.test($x) \nRCall.RObject{RCall.VecSxp}\n\n    One Sample t-test\n\ndata:  $x\nt = -1.7817, df = 9, p-value = 0.1085\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n -1.2239875  0.1454214\nsample estimates:\n mean of x\n-0.5392831  It is also possible to pass Julia expressions which are evaluated before being passed to R: these should be included in parentheses  julia  R optim(0, $(x -  x-cos(x)), method='BFGS') \nRCall.RObject{RCall.VecSxp}\n$par\n[1] -1.56343\n\n$value\n[1] -1.570796\n\n$counts\nfunction gradient\n      14       13\n\n$convergence\n[1] 0\n\n$message\nNULL", 
            "title": "R\"\" string macro"
        }, 
        {
            "location": "/gettingstarted/#rcopy", 
            "text": "The  rcopy  function converts  RObject s to Julia objects. It uses a variety of heuristics to pick the most appropriate Julia type:  julia  rcopy(R c(1) )\n1.0\n\njulia  rcopy(R c(1,2) )\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\njulia  rcopy(R list(1,'zz') )\n2-element Array{Any,1}:\n 1.0\n   zz \n\njulia  rcopy(R list(a=1,b='zz') )\nDict{Symbol,Any} with 2 entries:\n  :a =  1.0\n  :b =   zz   It is possible to force a specific conversion by passing the output type as the first argument:  julia  rcopy(Array{Int},R c(1,2) )\n2-element Array{Int64,1}:\n 1\n 2", 
            "title": "rcopy"
        }, 
        {
            "location": "/public/", 
            "text": "Public API\n\n\n\n\nTypes\n\n\n#\n\n\nRCall.AnySxp\n \n \nType\n.\n\n\nR \"any\" object\n\n\n#\n\n\nRCall.BcodeSxp\n \n \nType\n.\n\n\nR byte code\n\n\n#\n\n\nRCall.BuiltinSxp\n \n \nType\n.\n\n\nR built-in function\n\n\n#\n\n\nRCall.CharSxp\n \n \nType\n.\n\n\nR character string\n\n\n#\n\n\nRCall.ClosSxp\n \n \nType\n.\n\n\nR function closure\n\n\n#\n\n\nRCall.CplxSxp\n \n \nType\n.\n\n\nR complex vector\n\n\n#\n\n\nRCall.DotSxp\n \n \nType\n.\n\n\nR dot-dot-dot object\n\n\n#\n\n\nRCall.EnvSxp\n \n \nType\n.\n\n\nR environment\n\n\n#\n\n\nRCall.ExprSxp\n \n \nType\n.\n\n\nR expression vector\n\n\n#\n\n\nRCall.ExtPtrSxp\n \n \nType\n.\n\n\nR external pointer\n\n\n#\n\n\nRCall.IntSxp\n \n \nType\n.\n\n\nR integer vector\n\n\n#\n\n\nRCall.LangSxp\n \n \nType\n.\n\n\nR function call\n\n\n#\n\n\nRCall.LglSxp\n \n \nType\n.\n\n\nR logical vector\n\n\n#\n\n\nRCall.ListSxp\n \n \nType\n.\n\n\nR pairs (cons) list cell\n\n\n#\n\n\nRCall.NilSxp\n \n \nType\n.\n\n\nR NULL value\n\n\n#\n\n\nRCall.PromSxp\n \n \nType\n.\n\n\nR promise\n\n\n#\n\n\nRCall.RObject\n \n \nType\n.\n\n\nAn \nRObject\n is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the \nRObject\n itself is finalized by Julia. The parameter is the type of the S-expression.\n\n\nWhen called with a Julia object as an argument, a corresponding R object is constructed.\n\n\njulia\n RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia\n RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia\n RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3\n\n\n\n\n#\n\n\nRCall.RawSxp\n \n \nType\n.\n\n\nR byte vector\n\n\n#\n\n\nRCall.RealSxp\n \n \nType\n.\n\n\nR real vector\n\n\n#\n\n\nRCall.S4Sxp\n \n \nType\n.\n\n\nR S4 object\n\n\n#\n\n\nRCall.SpecialSxp\n \n \nType\n.\n\n\nR special function\n\n\n#\n\n\nRCall.StrSxp\n \n \nType\n.\n\n\nR vector of character strings\n\n\n#\n\n\nRCall.Sxp\n \n \nType\n.\n\n\nR symbolic expression (\nSxpPtr\n): these are represented by a pointer to a symbolic expression record (\nSxp\n).\n\n\n#\n\n\nRCall.SxpHead\n \n \nType\n.\n\n\nR Sxp header: a pointer to this is used for unknown types.\n\n\n#\n\n\nRCall.SymSxp\n \n \nType\n.\n\n\nR symbol\n\n\n#\n\n\nRCall.VecSxp\n \n \nType\n.\n\n\nR list (i.e. Array{Any,1})\n\n\n#\n\n\nRCall.WeakRefSxp\n \n \nType\n.\n\n\nR weak reference\n\n\n\n\nMethods\n\n\n#\n\n\nBase.eltype\n \n \nFunction\n.\n\n\nElement types of R vectors.\n\n\n#\n\n\nBase.getindex\n \n \nFunction\n.\n\n\nextract the value of symbol s in the environment e\n\n\nextract the i-th element of LangSxp l\n\n\nString indexing finds the first element with the matching name\n\n\nIndexing into \nVectorSxp\n types uses Julia indexing into the \nvec\n result, except for \nStrSxp\n and the \nVectorListSxp\n types, which must apply \nsexp\n to the \nPtr{Void}\n obtained by indexing into the \nvec\n result.\n\n\n#\n\n\nBase.isascii\n \n \nFunction\n.\n\n\nDetermines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).  * 0x00_0002_00 (bit 1): set of bytes (no known encoding)  * 0x00_0004_00 (bit 2): Latin-1  * 0x00_0008_00 (bit 3): UTF-8  * 0x00_0040_00 (bit 6): ASCII\n\n\nWe only support ASCII and UTF-8.\n\n\n#\n\n\nBase.length\n \n \nFunction\n.\n\n\nSxp methods for \nlength\n return the R length.\n\n\nRf_xlength\n handles Sxps that are not vector-like and R's \"long vectors\", which have a negative value for the \nlength\n member.\n\n\n#\n\n\nBase.setindex!\n \n \nFunction\n.\n\n\nassign value v to symbol s in the environment e\n\n\nassign value v to the i-th element of LangSxp l\n\n\n#\n\n\nRCall.NAel\n \n \nFunction\n.\n\n\nNA element for each type\n\n\n#\n\n\nRCall.anyNA\n \n \nFunction\n.\n\n\nCheck if there are any NA values in the vector.\n\n\n#\n\n\nRCall.bound\n \n \nFunction\n.\n\n\nThe R NAMED property, represented by 2 bits in the info field. This can take values 0,1 or 2, corresponding to whether it is bound to 0,1 or 2 or more symbols. See http://cran.r-project.org/doc/manuals/r-patched/R-exts.html#Named-objects-and-copying\n\n\n#\n\n\nRCall.callJuliaExtPtr\n \n \nFunction\n.\n\n\nThe function called by R .External for Julia callbacks.\n\n\nIt receives a \nListSxpPtr\n containing  - a pointer to the function itself (\nExtPtrSxpPtr\n)  - a pointer to the Julia function (\nExtPtrSxpPtr\n)  - any arguments (as \nSxpPtr\n)\n\n\n#\n\n\nRCall.dataptr\n \n \nFunction\n.\n\n\nPointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.\n\n\n#\n\n\nRCall.decrefExtPtr\n \n \nFunction\n.\n\n\nCalled by the R finalizer.\n\n\n#\n\n\nRCall.endEmbeddedR\n \n \nFunction\n.\n\n\nendEmbeddedR()\n\n\n\n\nClose embedded R session.\n\n\n#\n\n\nRCall.findNamespace\n \n \nFunction\n.\n\n\nfind namespace by name of the namespace, it is not error tolerant.\n\n\n#\n\n\nRCall.getAttrib\n \n \nFunction\n.\n\n\nReturn a particular attribute of an RObject\n\n\n#\n\n\nRCall.getClass\n \n \nFunction\n.\n\n\nReturns the class of an R object.\n\n\n#\n\n\nRCall.getNames\n \n \nFunction\n.\n\n\nReturns the names of an R vector.\n\n\n#\n\n\nRCall.getNamespace\n \n \nFunction\n.\n\n\nget namespace by name of the namespace. It is safer to be used than findNamespace as it checks bound.\n\n\n#\n\n\nRCall.ijulia_displayplots\n \n \nFunction\n.\n\n\nCalled after cell evaluation. Closes graphics device and displays files in notebook.\n\n\n#\n\n\nRCall.ijulia_setdevice\n \n \nFunction\n.\n\n\nSet options for R plotting with IJulia.\n\n\nThe first argument should be a MIME object: currently supported are * \nMIME(\"image/png\")\n [default] * \nMIME(\"image/svg+xml\")\n\n\nThe remaining arguments (keyword only) are passed to the appropriate R graphics device: see the relevant R help for details.\n\n\n#\n\n\nRCall.initEmbeddedR\n \n \nFunction\n.\n\n\ninitEmbeddedR()\n\n\n\n\nThis initializes an embedded R session. It should only be called when R is not already running (e.g. if Julia is running inside an R session)\n\n\n#\n\n\nRCall.isFactor\n \n \nFunction\n.\n\n\nCheck whether an R variable is a factor variable\n\n\n#\n\n\nRCall.isNA\n \n \nFunction\n.\n\n\nCheck if values correspond to R's sentinel NA values.\n\n\n#\n\n\nRCall.isOrdered\n \n \nFunction\n.\n\n\nCheck whether an R variable is an ordered factor variable\n\n\n#\n\n\nRCall.makeExternalPtr\n \n \nFunction\n.\n\n\nCreate an ExtPtrSxpPtr object\n\n\n#\n\n\nRCall.makeNativeSymbol\n \n \nFunction\n.\n\n\nRegister a function pointer as an R NativeSymbol.\n\n\nThis is completely undocumented, so may break: we technically are supposed to use R_registerRoutines, but this is \nmuch\n easier for just 1 function.\n\n\n#\n\n\nRCall.newEnvironment\n \n \nFunction\n.\n\n\nnewEnvironment([env])\n\n\n\n\nCreate a new environment which extends environment \nenv\n (\nglobalEnv\n by default).\n\n\n#\n\n\nRCall.preserve\n \n \nFunction\n.\n\n\nPrevent garbage collection of an R object. Object can be released via \nrelease\n.\n\n\nThis is slower than \nprotect\n, as it requires searching an internal list, but more flexible.\n\n\n#\n\n\nRCall.protect\n \n \nFunction\n.\n\n\nStack-based protection of garbage collection of R objects. Objects are released via \nunprotect\n. Returns the same pointer, allowing inline use.\n\n\nThis is faster than \npreserve\n, but more restrictive. Really only useful inside functions.\n\n\n#\n\n\nRCall.rcall\n \n \nFunction\n.\n\n\nEvaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.\n\n\n#\n\n\nRCall.rcopy\n \n \nFunction\n.\n\n\nEvaluate and convert the result of a string as an R expression.\n\n\nrcopy\n copies the contents of an R object into a corresponding canonical Julia type.\n\n\nrcopy(T,p)\n converts a pointer \np\n to a Sxp object to a native Julia object of type T.\n\n\nrcopy(p)\n performs a default conversion.\n\n\n#\n\n\nRCall.registerFinalizer\n \n \nFunction\n.\n\n\nRegister finalizer to be called by the R GC.\n\n\n#\n\n\nRCall.release\n \n \nFunction\n.\n\n\nRelease object that has been gc protected by \npreserve\n.\n\n\n#\n\n\nRCall.reval\n \n \nFunction\n.\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.\n\n\n#\n\n\nRCall.reval_p\n \n \nFunction\n.\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning a Sxp pointer.\n\n\n#\n\n\nRCall.rlang\n \n \nFunction\n.\n\n\nCreate a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated\n\n\n#\n\n\nRCall.rlang_p\n \n \nFunction\n.\n\n\nCreate a function call from a list of arguments\n\n\n#\n\n\nRCall.rparse\n \n \nFunction\n.\n\n\nParse a string as an R expression, returning an RObject.\n\n\n#\n\n\nRCall.rparse_p\n \n \nFunction\n.\n\n\nParse a string as an R expression, returning a Sxp pointer.\n\n\n#\n\n\nRCall.rprint\n \n \nFunction\n.\n\n\nParse, evaluate and print the result of a string as an R expression.\n\n\nPrint the value of an Sxp using R's printing mechanism\n\n\n#\n\n\nRCall.rscript\n \n \nFunction\n.\n\n\nParses an inline R script, substituting invalid \":($(Expr(:incomplete, \"incomplete: invalid string syntax\")))\n\n\n#\n\n\nRCall.setAttrib!\n \n \nFunction\n.\n\n\nSet a particular attribute of an RObject\n\n\n#\n\n\nRCall.setClass!\n \n \nFunction\n.\n\n\nSet the class of an R object.\n\n\n#\n\n\nRCall.setNames!\n \n \nFunction\n.\n\n\nSet the names of an R vector.\n\n\n#\n\n\nRCall.sexp\n \n \nFunction\n.\n\n\nWrap a callable Julia object \nf\n an a R \nClosSxpPtr\n.\n\n\nConstructs the following R code\n\n\nfunction(...) .External(juliaCallback, fExPtr, ...)\n\n\n\n\nWrap a Julia object an a R \nExtPtrSxpPtr\n.\n\n\nWe store the pointer and the object in a const Dict to prevent it being removed by the Julia GC.\n\n\nCreate a \nStrSxp\n from an \nAbstractString\n\n\nCreate a \nCharSxp\n from a String.\n\n\nGeneric function for constructing Sxps from Julia objects.\n\n\nCreate a \nSymSxp\n from a \nSymbol\n\n\nsexp(S,x)\n converts a Julia object \nx\n to a pointer to a Sxp object of type \nS\n.\n\n\nsexp(x)\n performs a default conversion.\n\n\nConvert a \nUnknownSxpPtr\n to an approptiate \nSxpPtr\n.\n\n\n#\n\n\nRCall.sexp_arglist_dots\n \n \nFunction\n.\n\n\nCreate an argument list for an R function call, with a varargs \"dots\" at the end.\n\n\n#\n\n\nRCall.sexpnum\n \n \nFunction\n.\n\n\nThe SEXPTYPE number of a \nSxp\n\n\nDetermined from the trailing 5 bits of the first 32-bit word. Is a 0-based index into the \ninfo\n field of a \nSxpHead\n.\n\n\n#\n\n\nRCall.unprotect\n \n \nFunction\n.\n\n\nRelease last \nn\n objects gc-protected by \nprotect\n.\n\n\n#\n\n\nRCall.unsafe_array\n \n \nFunction\n.\n\n\nThe same as \nunsafe_vec\n, except returns an appropriately sized array.\n\n\n#\n\n\nRCall.unsafe_vec\n \n \nFunction\n.\n\n\nRepresent the contents of a VectorSxp type as a \nVector\n.\n\n\nThis does \nnot\n copy the contents.  If the argument is not named (in R) or otherwise protected from R's garbage collection (e.g. by keeping the containing RObject in scope) the contents of this vector can be modified or could cause a memory error when accessed.\n\n\nThe contents are as stored in R.  Missing values (NA's) are represented in R by sentinels.  Missing data values in RealSxp and CplxSxp show up as \nNaN\n and \nNaN + NaNim\n, respectively.  Missing data in IntSxp show up as \n-2147483648\n, the minimum 32-bit integer value.  Internally a \nLglSxp\n is represented as \nVector{Int32}\n.  The convention is that \n0\n is \nfalse\n, \n-2147483648\n is \nNA\n and all other values represent \ntrue\n.\n\n\n\n\nMacros\n\n\n#\n\n\nRCall.@R_str\n \n \nMacro\n.\n\n\nR\n...\n\n\n\n\n\nAn inline R expression, the result of which is evaluated and returned as an \nRObject\n.\n\n\nIt supports substitution of Julia variables and expressions via prefix with \n$\n whenever not valid R syntax (i.e. when not immediately following another completed R expression):\n\n\nR\nglm(Sepal.Length ~ Sepal.Width, data=$iris)\n\n\n\n\n\nIt is also possible to pass Julia expressions:\n\n\nR\nplot((anonymous function))\n\n\n\n\n\nAll such Julia expressions are evaluated once, before the R expression is evaluated.\n\n\nThe expression does not support assigning to Julia variables, so the only way retrieve values from R via the return value.\n\n\nThe R expression is evaluated each time in a new environment, so standard R variable assignments (\n=\n or \n-\n) will not persist between expressions, or even multiple calls of the same expression. In order to persist variables, you should use the the double-assignment operator (\n-\n), which assigns the variable to the global environment.\n\n\n#\n\n\nRCall.@rget\n \n \nMacro\n.\n\n\nCopies variables from R to Julia using the same name.\n\n\n#\n\n\nRCall.@rimport\n \n \nMacro\n.\n\n\nImport an R Package as a Julia module. You can also use classic Python syntax to make an alias: \n@rimport *module-name* as *shorthand*\n\n\n#\n\n\nRCall.@rlibrary\n \n \nMacro\n.\n\n\nLoad all exported functions/objects of a R package to the current module.\n\n\n#\n\n\nRCall.@rput\n \n \nMacro\n.\n\n\nCopies variables from Julia to R using the same name.\n\n\n#\n\n\nRCall.@var_str\n \n \nMacro\n.\n\n\nReturns a variable named \"str\". Useful for passing keyword arguments containing dots.\n\n\n\n\nConstants\n\n\n#\n\n\nRCall.globalEnv\n \n \nConstant\n.\n\n\nR global Environment.\n\n\nglobalEnv[:x] = 1\nglobalEnv[:x]\n\n\n\n\n#\n\n\nRCall.jtypExtPtrs\n \n \nConstant\n.\n\n\nJulia types (typically functions) which are wrapped in \nExtPtrSxpPtr\n are stored here to prevent garbage collection by Julia.\n\n\n#\n\n\nRCall.typs\n \n \nConstant\n.\n\n\nvector of R Sxp types", 
            "title": "Public API"
        }, 
        {
            "location": "/public/#public-api", 
            "text": "", 
            "title": "Public API"
        }, 
        {
            "location": "/public/#types", 
            "text": "#  RCall.AnySxp     Type .  R \"any\" object  #  RCall.BcodeSxp     Type .  R byte code  #  RCall.BuiltinSxp     Type .  R built-in function  #  RCall.CharSxp     Type .  R character string  #  RCall.ClosSxp     Type .  R function closure  #  RCall.CplxSxp     Type .  R complex vector  #  RCall.DotSxp     Type .  R dot-dot-dot object  #  RCall.EnvSxp     Type .  R environment  #  RCall.ExprSxp     Type .  R expression vector  #  RCall.ExtPtrSxp     Type .  R external pointer  #  RCall.IntSxp     Type .  R integer vector  #  RCall.LangSxp     Type .  R function call  #  RCall.LglSxp     Type .  R logical vector  #  RCall.ListSxp     Type .  R pairs (cons) list cell  #  RCall.NilSxp     Type .  R NULL value  #  RCall.PromSxp     Type .  R promise  #  RCall.RObject     Type .  An  RObject  is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the  RObject  itself is finalized by Julia. The parameter is the type of the S-expression.  When called with a Julia object as an argument, a corresponding R object is constructed.  julia  RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia  RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia  RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3  #  RCall.RawSxp     Type .  R byte vector  #  RCall.RealSxp     Type .  R real vector  #  RCall.S4Sxp     Type .  R S4 object  #  RCall.SpecialSxp     Type .  R special function  #  RCall.StrSxp     Type .  R vector of character strings  #  RCall.Sxp     Type .  R symbolic expression ( SxpPtr ): these are represented by a pointer to a symbolic expression record ( Sxp ).  #  RCall.SxpHead     Type .  R Sxp header: a pointer to this is used for unknown types.  #  RCall.SymSxp     Type .  R symbol  #  RCall.VecSxp     Type .  R list (i.e. Array{Any,1})  #  RCall.WeakRefSxp     Type .  R weak reference", 
            "title": "Types"
        }, 
        {
            "location": "/public/#methods", 
            "text": "#  Base.eltype     Function .  Element types of R vectors.  #  Base.getindex     Function .  extract the value of symbol s in the environment e  extract the i-th element of LangSxp l  String indexing finds the first element with the matching name  Indexing into  VectorSxp  types uses Julia indexing into the  vec  result, except for  StrSxp  and the  VectorListSxp  types, which must apply  sexp  to the  Ptr{Void}  obtained by indexing into the  vec  result.  #  Base.isascii     Function .  Determines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).  * 0x00_0002_00 (bit 1): set of bytes (no known encoding)  * 0x00_0004_00 (bit 2): Latin-1  * 0x00_0008_00 (bit 3): UTF-8  * 0x00_0040_00 (bit 6): ASCII  We only support ASCII and UTF-8.  #  Base.length     Function .  Sxp methods for  length  return the R length.  Rf_xlength  handles Sxps that are not vector-like and R's \"long vectors\", which have a negative value for the  length  member.  #  Base.setindex!     Function .  assign value v to symbol s in the environment e  assign value v to the i-th element of LangSxp l  #  RCall.NAel     Function .  NA element for each type  #  RCall.anyNA     Function .  Check if there are any NA values in the vector.  #  RCall.bound     Function .  The R NAMED property, represented by 2 bits in the info field. This can take values 0,1 or 2, corresponding to whether it is bound to 0,1 or 2 or more symbols. See http://cran.r-project.org/doc/manuals/r-patched/R-exts.html#Named-objects-and-copying  #  RCall.callJuliaExtPtr     Function .  The function called by R .External for Julia callbacks.  It receives a  ListSxpPtr  containing  - a pointer to the function itself ( ExtPtrSxpPtr )  - a pointer to the Julia function ( ExtPtrSxpPtr )  - any arguments (as  SxpPtr )  #  RCall.dataptr     Function .  Pointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.  #  RCall.decrefExtPtr     Function .  Called by the R finalizer.  #  RCall.endEmbeddedR     Function .  endEmbeddedR()  Close embedded R session.  #  RCall.findNamespace     Function .  find namespace by name of the namespace, it is not error tolerant.  #  RCall.getAttrib     Function .  Return a particular attribute of an RObject  #  RCall.getClass     Function .  Returns the class of an R object.  #  RCall.getNames     Function .  Returns the names of an R vector.  #  RCall.getNamespace     Function .  get namespace by name of the namespace. It is safer to be used than findNamespace as it checks bound.  #  RCall.ijulia_displayplots     Function .  Called after cell evaluation. Closes graphics device and displays files in notebook.  #  RCall.ijulia_setdevice     Function .  Set options for R plotting with IJulia.  The first argument should be a MIME object: currently supported are *  MIME(\"image/png\")  [default] *  MIME(\"image/svg+xml\")  The remaining arguments (keyword only) are passed to the appropriate R graphics device: see the relevant R help for details.  #  RCall.initEmbeddedR     Function .  initEmbeddedR()  This initializes an embedded R session. It should only be called when R is not already running (e.g. if Julia is running inside an R session)  #  RCall.isFactor     Function .  Check whether an R variable is a factor variable  #  RCall.isNA     Function .  Check if values correspond to R's sentinel NA values.  #  RCall.isOrdered     Function .  Check whether an R variable is an ordered factor variable  #  RCall.makeExternalPtr     Function .  Create an ExtPtrSxpPtr object  #  RCall.makeNativeSymbol     Function .  Register a function pointer as an R NativeSymbol.  This is completely undocumented, so may break: we technically are supposed to use R_registerRoutines, but this is  much  easier for just 1 function.  #  RCall.newEnvironment     Function .  newEnvironment([env])  Create a new environment which extends environment  env  ( globalEnv  by default).  #  RCall.preserve     Function .  Prevent garbage collection of an R object. Object can be released via  release .  This is slower than  protect , as it requires searching an internal list, but more flexible.  #  RCall.protect     Function .  Stack-based protection of garbage collection of R objects. Objects are released via  unprotect . Returns the same pointer, allowing inline use.  This is faster than  preserve , but more restrictive. Really only useful inside functions.  #  RCall.rcall     Function .  Evaluate a function in the global environment. The first argument corresponds to the function to be called. It can be either a FunctionSxp type, a SymSxp or a Symbol.  #  RCall.rcopy     Function .  Evaluate and convert the result of a string as an R expression.  rcopy  copies the contents of an R object into a corresponding canonical Julia type.  rcopy(T,p)  converts a pointer  p  to a Sxp object to a native Julia object of type T.  rcopy(p)  performs a default conversion.  #  RCall.registerFinalizer     Function .  Register finalizer to be called by the R GC.  #  RCall.release     Function .  Release object that has been gc protected by  preserve .  #  RCall.reval     Function .  Evaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning an RObject.  #  RCall.reval_p     Function .  Evaluate an R symbol or language object (i.e. a function call) in an R try/catch block, returning a Sxp pointer.  #  RCall.rlang     Function .  Create a function call from a function pointer and a list of arguments and return it as an RObject, which can then be evaulated  #  RCall.rlang_p     Function .  Create a function call from a list of arguments  #  RCall.rparse     Function .  Parse a string as an R expression, returning an RObject.  #  RCall.rparse_p     Function .  Parse a string as an R expression, returning a Sxp pointer.  #  RCall.rprint     Function .  Parse, evaluate and print the result of a string as an R expression.  Print the value of an Sxp using R's printing mechanism  #  RCall.rscript     Function .  Parses an inline R script, substituting invalid \":($(Expr(:incomplete, \"incomplete: invalid string syntax\")))  #  RCall.setAttrib!     Function .  Set a particular attribute of an RObject  #  RCall.setClass!     Function .  Set the class of an R object.  #  RCall.setNames!     Function .  Set the names of an R vector.  #  RCall.sexp     Function .  Wrap a callable Julia object  f  an a R  ClosSxpPtr .  Constructs the following R code  function(...) .External(juliaCallback, fExPtr, ...)  Wrap a Julia object an a R  ExtPtrSxpPtr .  We store the pointer and the object in a const Dict to prevent it being removed by the Julia GC.  Create a  StrSxp  from an  AbstractString  Create a  CharSxp  from a String.  Generic function for constructing Sxps from Julia objects.  Create a  SymSxp  from a  Symbol  sexp(S,x)  converts a Julia object  x  to a pointer to a Sxp object of type  S .  sexp(x)  performs a default conversion.  Convert a  UnknownSxpPtr  to an approptiate  SxpPtr .  #  RCall.sexp_arglist_dots     Function .  Create an argument list for an R function call, with a varargs \"dots\" at the end.  #  RCall.sexpnum     Function .  The SEXPTYPE number of a  Sxp  Determined from the trailing 5 bits of the first 32-bit word. Is a 0-based index into the  info  field of a  SxpHead .  #  RCall.unprotect     Function .  Release last  n  objects gc-protected by  protect .  #  RCall.unsafe_array     Function .  The same as  unsafe_vec , except returns an appropriately sized array.  #  RCall.unsafe_vec     Function .  Represent the contents of a VectorSxp type as a  Vector .  This does  not  copy the contents.  If the argument is not named (in R) or otherwise protected from R's garbage collection (e.g. by keeping the containing RObject in scope) the contents of this vector can be modified or could cause a memory error when accessed.  The contents are as stored in R.  Missing values (NA's) are represented in R by sentinels.  Missing data values in RealSxp and CplxSxp show up as  NaN  and  NaN + NaNim , respectively.  Missing data in IntSxp show up as  -2147483648 , the minimum 32-bit integer value.  Internally a  LglSxp  is represented as  Vector{Int32} .  The convention is that  0  is  false ,  -2147483648  is  NA  and all other values represent  true .", 
            "title": "Methods"
        }, 
        {
            "location": "/public/#macros", 
            "text": "#  RCall.@R_str     Macro .  R ...   An inline R expression, the result of which is evaluated and returned as an  RObject .  It supports substitution of Julia variables and expressions via prefix with  $  whenever not valid R syntax (i.e. when not immediately following another completed R expression):  R glm(Sepal.Length ~ Sepal.Width, data=$iris)   It is also possible to pass Julia expressions:  R plot((anonymous function))   All such Julia expressions are evaluated once, before the R expression is evaluated.  The expression does not support assigning to Julia variables, so the only way retrieve values from R via the return value.  The R expression is evaluated each time in a new environment, so standard R variable assignments ( =  or  - ) will not persist between expressions, or even multiple calls of the same expression. In order to persist variables, you should use the the double-assignment operator ( - ), which assigns the variable to the global environment.  #  RCall.@rget     Macro .  Copies variables from R to Julia using the same name.  #  RCall.@rimport     Macro .  Import an R Package as a Julia module. You can also use classic Python syntax to make an alias:  @rimport *module-name* as *shorthand*  #  RCall.@rlibrary     Macro .  Load all exported functions/objects of a R package to the current module.  #  RCall.@rput     Macro .  Copies variables from Julia to R using the same name.  #  RCall.@var_str     Macro .  Returns a variable named \"str\". Useful for passing keyword arguments containing dots.", 
            "title": "Macros"
        }, 
        {
            "location": "/public/#constants", 
            "text": "#  RCall.globalEnv     Constant .  R global Environment.  globalEnv[:x] = 1\nglobalEnv[:x]  #  RCall.jtypExtPtrs     Constant .  Julia types (typically functions) which are wrapped in  ExtPtrSxpPtr  are stored here to prevent garbage collection by Julia.  #  RCall.typs     Constant .  vector of R Sxp types", 
            "title": "Constants"
        }
    ]
}