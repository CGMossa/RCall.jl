{
    "docs": [
        {
            "location": "/", 
            "text": "RCall.jl\n\n\nR\n has been round for a couple of decades.  In the\nlast few years, a new language for technical computing,\n\nJulia\n, has arrived and provides remarkable performance\nvia Just-In-Time (JIT) compilation of functions than in R, but there are still\na lot of well-developed packages in R that could use in Julia.  The\n\nRCall\n package is a way of\nestablishing communication between to two.\n\n\nIt is a pure Julia package.  In other words, there is\nno code in C or C++ or another such language necessary to implement\ncalling R from Julia. It is possible to exploit the advantages of both\nlanguages.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#rcalljl", 
            "text": "R  has been round for a couple of decades.  In the\nlast few years, a new language for technical computing, Julia , has arrived and provides remarkable performance\nvia Just-In-Time (JIT) compilation of functions than in R, but there are still\na lot of well-developed packages in R that could use in Julia.  The RCall  package is a way of\nestablishing communication between to two.  It is a pure Julia package.  In other words, there is\nno code in C or C++ or another such language necessary to implement\ncalling R from Julia. It is possible to exploit the advantages of both\nlanguages.", 
            "title": "RCall.jl"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing RCall.jl\n\n\nRCall.jl requires that a recent version of R, at least 3.2.0, be installed. \n\n\nStandard installations\n\n\nIf R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with\n\n\nPkg.add(\nRCall\n)\n\n\n\n\nShould you experience problems with any of these methods, please \nopen an issue\n.\n\n\nWindows\n\n\nThe current \nWindows binary from CRAN\n.\n\n\nOS X\n\n\nThe \nCRAN .pkg\n or the \nhomebrew/science\n tap.\n\n\nLinux\n\n\nMost Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from \nCRAN\n.\n\n\nUpdating R\n\n\nIf you have updated the R installation, you may need to rebuild RCall via\n\n\nPkg.build(\nRCall\n)\n\n\n\n\nThis should be done from within a new Julia session (i.e. before RCall has been loaded).\n\n\nOther methods\n\n\nIf you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).\n\n\nLinux and OS X\n\n\nFirstly, try setting the \nR_HOME\n environmental variable to the location of your R installation. This can be set in your \n~/.juliarc.jl\n file via the \nENV\n global variable, e.g.\n\n\nENV[\nR_HOME\n] = ...\n\n\n\n\nThen from within a new Julia session, try running\n\n\nPkg.build(\nRCall\n)\n\n\n\n\nIf that fails, you may need to also set the following environmental variables:\n\n\n\n\nR_HOME\n\n\nR_DOC_DIR\n\n\nR_INCLUDE_DIR\n\n\nR_SHARE_DIR\n\n\nLD_LIBRARY_PATH\n\n\n\n\nWindows\n\n\nThe \nPATH\n environmental variable should contain the location of your R binary, and the \nHOME\n variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-rcalljl", 
            "text": "RCall.jl requires that a recent version of R, at least 3.2.0, be installed.", 
            "title": "Installing RCall.jl"
        }, 
        {
            "location": "/installation/#standard-installations", 
            "text": "If R has been installed using one of the standard approaches below, then RCall.jl can simply be installed with  Pkg.add( RCall )  Should you experience problems with any of these methods, please  open an issue .  Windows  The current  Windows binary from CRAN .  OS X  The  CRAN .pkg  or the  homebrew/science  tap.  Linux  Most Linux distributions allow installation of R from their package manager, however these are often out of date, and may not work with RCall.jl. We recommend that you use the updated repositories from  CRAN .", 
            "title": "Standard installations"
        }, 
        {
            "location": "/installation/#updating-r", 
            "text": "If you have updated the R installation, you may need to rebuild RCall via  Pkg.build( RCall )  This should be done from within a new Julia session (i.e. before RCall has been loaded).", 
            "title": "Updating R"
        }, 
        {
            "location": "/installation/#other-methods", 
            "text": "If you have installed R by some other method, then some further modifications may be necessary, for example, if you're building R from scratch, or the files have been copied but not installed in the usual manner (common on cluster installations).  Linux and OS X  Firstly, try setting the  R_HOME  environmental variable to the location of your R installation. This can be set in your  ~/.juliarc.jl  file via the  ENV  global variable, e.g.  ENV[ R_HOME ] = ...  Then from within a new Julia session, try running  Pkg.build( RCall )  If that fails, you may need to also set the following environmental variables:   R_HOME  R_DOC_DIR  R_INCLUDE_DIR  R_SHARE_DIR  LD_LIBRARY_PATH   Windows  The  PATH  environmental variable should contain the location of your R binary, and the  HOME  variable should contain the current user's home directory. These need to be set before Julia is started.", 
            "title": "Other methods"
        }, 
        {
            "location": "/api/RCall/", 
            "text": "RCall\n\n\nMethods [Exported]\n\n\n\n\n\n\nanyNA{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp}) \n\u00b6\n\n\nCheck if there are any NA values in the vector.\n\n\nsource:\n\n\nRCall/src/methods.jl:309\n\n\n\n\n\n\ngetNames{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp}) \n\u00b6\n\n\nReturns the names of an R vector.\n\n\nsource:\n\n\nRCall/src/methods.jl:234\n\n\n\n\n\n\nisNA(x::Complex{Float64}) \n\u00b6\n\n\nCheck if values correspond to R's sentinel NA values.\n\n\nsource:\n\n\nRCall/src/methods.jl:288\n\n\n\n\n\n\nrcall(f,  args...) \n\u00b6\n\n\nEvaluate a function in the global environment. The first argument corresponds\nto the function to be called. It can be either a FunctionSxp type, a SymSxp or\na Symbol.\n\n\nsource:\n\n\nRCall/src/functions.jl:25\n\n\n\n\n\n\nrcopy(s::Ptr{RCall.SymSxp}) \n\u00b6\n\n\nrcopy\n copies the contents of an R object into a corresponding canonical Julia type.\n\n\nsource:\n\n\nRCall/src/convert-default.jl:6\n\n\n\n\n\n\nrcopy(str::AbstractString) \n\u00b6\n\n\nEvaluate and convert the result of a string as an R expression.\n\n\nsource:\n\n\nRCall/src/iface.jl:40\n\n\n\n\n\n\nrcopy{S\n:RCall.Sxp}(::Type{Any},  x::Ptr{S\n:RCall.Sxp}) \n\u00b6\n\n\nrcopy(T,p)\n converts a pointer \np\n to a Sxp object to a native Julia object of type T.\n\n\nrcopy(p)\n performs a default conversion.\n\n\nsource:\n\n\nRCall/src/convert-base.jl:9\n\n\n\n\n\n\nreval(s) \n\u00b6\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R\ntry/catch block, returning an RObject.\n\n\nsource:\n\n\nRCall/src/iface.jl:32\n\n\n\n\n\n\nreval(s,  env) \n\u00b6\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R\ntry/catch block, returning an RObject.\n\n\nsource:\n\n\nRCall/src/iface.jl:32\n\n\n\n\n\n\nrparse(st::AbstractString) \n\u00b6\n\n\nParse a string as an R expression, returning an RObject.\n\n\nsource:\n\n\nRCall/src/iface.jl:63\n\n\n\n\n\n\nrprint(io::IO,  str::ByteString) \n\u00b6\n\n\nParse, evaluate and print the result of a string as an R expression.\n\n\nsource:\n\n\nRCall/src/iface.jl:102\n\n\n\n\n\n\nrprint{S\n:RCall.Sxp}(io::IO,  s::Ptr{S\n:RCall.Sxp}) \n\u00b6\n\n\nPrint the value of an Sxp using R's printing mechanism\n\n\nsource:\n\n\nRCall/src/iface.jl:67\n\n\n\n\n\n\nsetNames!{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp},  n::Ptr{RCall.StrSxp}) \n\u00b6\n\n\nSet the names of an R vector.\n\n\nsource:\n\n\nRCall/src/methods.jl:240\n\n\nTypes [Exported]\n\n\n\n\n\n\nRCall.CharSxp \n\u00b6\n\n\nR character string\n\n\nsource:\n\n\nRCall/src/types.jl:91\n\n\n\n\n\n\nRCall.ClosSxp \n\u00b6\n\n\nR function closure\n\n\nsource:\n\n\nRCall/src/types.jl:43\n\n\n\n\n\n\nRCall.CplxSxp \n\u00b6\n\n\nR complex vector\n\n\nsource:\n\n\nRCall/src/types.jl:132\n\n\n\n\n\n\nRCall.IntSxp \n\u00b6\n\n\nR integer vector\n\n\nsource:\n\n\nRCall/src/types.jl:116\n\n\n\n\n\n\nRCall.LglSxp \n\u00b6\n\n\nR logical vector\n\n\nsource:\n\n\nRCall/src/types.jl:108\n\n\n\n\n\n\nRCall.NilSxp \n\u00b6\n\n\nR NULL value\n\n\nsource:\n\n\nRCall/src/types.jl:28\n\n\n\n\n\n\nRCall.RObject{S\n:RCall.Sxp} \n\u00b6\n\n\nAn \nRObject\n is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the \nRObject\n itself is finalized by Julia. The parameter is the type of the S-expression.\n\n\nWhen called with a Julia object as an argument, a corresponding R object is constructed.\n\n\njulia\n RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia\n RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia\n RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3\n\n\n\n\nsource:\n\n\nRCall/src/types.jl:257\n\n\n\n\n\n\nRCall.RealSxp \n\u00b6\n\n\nR real vector\n\n\nsource:\n\n\nRCall/src/types.jl:124\n\n\n\n\n\n\nRCall.StrSxp \n\u00b6\n\n\nR vector of character strings\n\n\nsource:\n\n\nRCall/src/types.jl:140\n\n\n\n\n\n\nRCall.Sxp \n\u00b6\n\n\nR symbolic expression (\nSxpPtr\n): these are represented by a pointer to a\nsymbolic expression record (\nSxp\n).\n\n\nsource:\n\n\nRCall/src/types.jl:5\n\n\nMacros [Exported]\n\n\n\n\n\n\n@rget(args...) \n\u00b6\n\n\nCopies variables from R to Julia using the same name.\n\n\nsource:\n\n\nRCall/src/iface.jl:128\n\n\n\n\n\n\n@rput(args...) \n\u00b6\n\n\nCopies variables from Julia to R using the same name.\n\n\nsource:\n\n\nRCall/src/iface.jl:108\n\n\n\n\n\n\n@var_str(str) \n\u00b6\n\n\nReturns a variable named \"str\". Useful for passing keyword arguments containing dots.\n\n\nsource:\n\n\nRCall/src/functions.jl:35\n\n\nMethods [Internal]\n\n\n\n\n\n\nNAel(::Type{RCall.LglSxp}) \n\u00b6\n\n\nNA element for each type\n\n\nsource:\n\n\nRCall/src/methods.jl:277\n\n\n\n\n\n\nbound{S\n:RCall.Sxp}(s::Ptr{S\n:RCall.Sxp}) \n\u00b6\n\n\nThe R NAMED property, represented by 2 bits in the info field. This can take\nvalues 0,1 or 2, corresponding to whether it is bound to 0,1 or 2 or more\nsymbols. See\nhttp://cran.r-project.org/doc/manuals/r-patched/R-exts.html#Named-objects-and-copying\n\n\nsource:\n\n\nRCall/src/methods.jl:12\n\n\n\n\n\n\ncallJuliaExtPtr(p::Ptr{RCall.ListSxp}) \n\u00b6\n\n\nThe function called by R .External for Julia callbacks.\n\n\nIt receives a \nListSxpPtr\n containing\n - a pointer to the function itself (\nExtPtrSxpPtr\n)\n - a pointer to the Julia function (\nExtPtrSxpPtr\n)\n - any arguments (as \nSxpPtr\n)\n\n\nsource:\n\n\nRCall/src/callback.jl:32\n\n\n\n\n\n\ndataptr{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp}) \n\u00b6\n\n\nPointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.\n\n\nsource:\n\n\nRCall/src/methods.jl:47\n\n\n\n\n\n\ndecrefExtPtr(p::Ptr{RCall.ExtPtrSxp}) \n\u00b6\n\n\nCalled by the R finalizer.\n\n\nsource:\n\n\nRCall/src/callback.jl:76\n\n\n\n\n\n\neltype(::Type{RCall.LglSxp}) \n\u00b6\n\n\nElement types of R vectors.\n\n\nsource:\n\n\nRCall/src/types.jl:222\n\n\n\n\n\n\nfindNamespace(str::ByteString) \n\u00b6\n\n\nfind namespace by name of the namespace\n\n\nsource:\n\n\nRCall/src/methods.jl:386\n\n\n\n\n\n\ngetClass{S\n:RCall.Sxp}(s::Ptr{S\n:RCall.Sxp}) \n\u00b6\n\n\nReturns the class of an R object.\n\n\nsource:\n\n\nRCall/src/methods.jl:246\n\n\n\n\n\n\ngetindex(e::Ptr{RCall.EnvSxp},  s::Ptr{RCall.SymSxp}) \n\u00b6\n\n\nextract the value of symbol s in the environment e\n\n\nsource:\n\n\nRCall/src/methods.jl:354\n\n\n\n\n\n\ngetindex{S\n:RCall.PairListSxp}(l::Ptr{S\n:RCall.PairListSxp},  I::Integer) \n\u00b6\n\n\nextract the i-th element of LangSxp l\n\n\nsource:\n\n\nRCall/src/methods.jl:177\n\n\n\n\n\n\ngetindex{S\n:RCall.VectorAtomicSxp}(s::Ptr{S\n:RCall.VectorAtomicSxp},  I::Real) \n\u00b6\n\n\nIndexing into \nVectorSxp\n types uses Julia indexing into the \nvec\n result,\nexcept for \nStrSxp\n and the \nVectorListSxp\n types, which must apply \nsexp\n\nto the \nPtr{Void}\n obtained by indexing into the \nvec\n result.\n\n\nsource:\n\n\nRCall/src/methods.jl:80\n\n\n\n\n\n\ngetindex{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp},  label::AbstractString) \n\u00b6\n\n\nString indexing finds the first element with the matching name\n\n\nsource:\n\n\nRCall/src/methods.jl:91\n\n\n\n\n\n\nijulia_displayplots() \n\u00b6\n\n\nCalled after cell evaluation.\nCloses graphics device and displays files in notebook.\n\n\nsource:\n\n\nRCall/src/IJulia.jl:53\n\n\n\n\n\n\nijulia_setdevice(m::MIME{mime}) \n\u00b6\n\n\nSet options for R plotting with IJulia.\n\n\nThe first argument should be a MIME object: currently supported are\n\n \nMIME(\"image/png\")\n [default]\n\n \nMIME(\"image/svg+xml\")\n\n\nThe remaining arguments (keyword only) are passed to the appropriate R graphics\ndevice: see the relevant R help for details.\n\n\nsource:\n\n\nRCall/src/IJulia.jl:17\n\n\n\n\n\n\nisascii(s::RCall.CharSxp) \n\u00b6\n\n\nDetermines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).\n * 0x00_0002_00 (bit 1): set of bytes (no known encoding)\n * 0x00_0004_00 (bit 2): Latin-1\n * 0x00_0008_00 (bit 3): UTF-8\n * 0x00_0040_00 (bit 6): ASCII\n\n\nWe only support ASCII and UTF-8.\n\n\nsource:\n\n\nRCall/src/methods.jl:330\n\n\n\n\n\n\nlength{S\n:RCall.Sxp}(s::Ptr{S\n:RCall.Sxp}) \n\u00b6\n\n\nSxp methods for \nlength\n return the R length.\n\n\nRf_xlength\n handles Sxps that are not vector-like and R's\n\"long vectors\", which have a negative value for the \nlength\n member.\n\n\nsource:\n\n\nRCall/src/methods.jl:24\n\n\n\n\n\n\nmakeExternalPtr(ptr::Ptr{Void}) \n\u00b6\n\n\nCreate an ExtPtrSxpPtr object\n\n\nsource:\n\n\nRCall/src/callback.jl:18\n\n\n\n\n\n\nmakeExternalPtr(ptr::Ptr{Void},  tag) \n\u00b6\n\n\nCreate an ExtPtrSxpPtr object\n\n\nsource:\n\n\nRCall/src/callback.jl:18\n\n\n\n\n\n\nmakeExternalPtr(ptr::Ptr{Void},  tag,  prot) \n\u00b6\n\n\nCreate an ExtPtrSxpPtr object\n\n\nsource:\n\n\nRCall/src/callback.jl:18\n\n\n\n\n\n\nmakeNativeSymbol(fptr::Ptr{Void}) \n\u00b6\n\n\nRegister a function pointer as an R NativeSymbol.\n\n\nThis is completely undocumented, so may break: we technically are supposed to\nuse R_registerRoutines, but this is \nmuch\n easier for just 1 function.\n\n\nsource:\n\n\nRCall/src/callback.jl:7\n\n\n\n\n\n\nnewEnvironment(env::Ptr{RCall.EnvSxp}) \n\u00b6\n\n\ncreate a new environment which extends env\n\n\nsource:\n\n\nRCall/src/methods.jl:380\n\n\n\n\n\n\npreserve{S\n:RCall.Sxp}(p::Ptr{S\n:RCall.Sxp}) \n\u00b6\n\n\nPrevent garbage collection of an R object. Object can be released via \nrelease\n.\n\n\nThis is slower than \nprotect\n, as it requires searching an internal list, but\nmore flexible.\n\n\nsource:\n\n\nRCall/src/types.jl:281\n\n\n\n\n\n\nprotect{S\n:RCall.Sxp}(p::Ptr{S\n:RCall.Sxp}) \n\u00b6\n\n\nStack-based protection of garbage collection of R objects. Objects are\nreleased via \nunprotect\n. Returns the same pointer, allowing inline use.\n\n\nThis is faster than \npreserve\n, but more restrictive. Really only useful\ninside functions.\n\n\nsource:\n\n\nRCall/src/types.jl:296\n\n\n\n\n\n\nregisterFinalizer(s::Ptr{RCall.ExtPtrSxp}) \n\u00b6\n\n\nRegister finalizer to be called by the R GC.\n\n\nsource:\n\n\nRCall/src/callback.jl:85\n\n\n\n\n\n\nrelease{S\n:RCall.Sxp}(p::Ptr{S\n:RCall.Sxp}) \n\u00b6\n\n\nRelease object that has been gc protected by \npreserve\n.\n\n\nsource:\n\n\nRCall/src/types.jl:286\n\n\n\n\n\n\nreval_p{S\n:RCall.Sxp}(expr::Ptr{S\n:RCall.Sxp},  env::Ptr{RCall.EnvSxp}) \n\u00b6\n\n\nEvaluate an R symbol or language object (i.e. a function call) in an R\ntry/catch block, returning a Sxp pointer.\n\n\nsource:\n\n\nRCall/src/iface.jl:5\n\n\n\n\n\n\nrlang_p(f,  args...) \n\u00b6\n\n\nCreate a function call from a list of arguments\n\n\nsource:\n\n\nRCall/src/functions.jl:2\n\n\n\n\n\n\nrparse_p(st::Ptr{RCall.StrSxp}) \n\u00b6\n\n\nParse a string as an R expression, returning a Sxp pointer.\n\n\nsource:\n\n\nRCall/src/iface.jl:47\n\n\n\n\n\n\nsetClass!{S\n:RCall.Sxp}(s::Ptr{S\n:RCall.Sxp},  c::Ptr{RCall.StrSxp}) \n\u00b6\n\n\nSet the class of an R object.\n\n\nsource:\n\n\nRCall/src/methods.jl:253\n\n\n\n\n\n\nsetindex!{S\n:RCall.PairListSxp, T\n:RCall.Sxp}(l::Ptr{S\n:RCall.PairListSxp},  v::Ptr{T\n:RCall.Sxp},  I::Integer) \n\u00b6\n\n\nassign value v to the i-th element of LangSxp l\n\n\nsource:\n\n\nRCall/src/methods.jl:188\n\n\n\n\n\n\nsetindex!{S\n:RCall.Sxp}(e::Ptr{RCall.EnvSxp},  v::Ptr{S\n:RCall.Sxp},  s::Ptr{RCall.SymSxp}) \n\u00b6\n\n\nassign value v to symbol s in the environment e\n\n\nsource:\n\n\nRCall/src/methods.jl:364\n\n\n\n\n\n\nsexp(::Type{Int32},  x) \n\u00b6\n\n\nsexp(S,x)\n converts a Julia object \nx\n to a pointer to a Sxp object of type \nS\n.\n\n\nsexp(x)\n performs a default conversion.\n\n\nsource:\n\n\nRCall/src/convert-base.jl:29\n\n\n\n\n\n\nsexp(::Type{RCall.CharSxp},  st::ASCIIString) \n\u00b6\n\n\nCreate a \nCharSxp\n from a String.\n\n\nsource:\n\n\nRCall/src/convert-base.jl:63\n\n\n\n\n\n\nsexp(::Type{RCall.ClosSxp},  f) \n\u00b6\n\n\nWrap a callable Julia object \nf\n an a R \nClosSxpPtr\n.\n\n\nConstructs the following R code\n\n\nfunction(...) .External(rJuliaCallback, fExPtr, ...)\n\n\n\nsource:\n\n\nRCall/src/callback.jl:118\n\n\n\n\n\n\nsexp(::Type{RCall.ExtPtrSxp},  j) \n\u00b6\n\n\nWrap a Julia object an a R \nExtPtrSxpPtr\n.\n\n\nWe store the pointer and the object in a const Dict to prevent it being\nremoved by the Julia GC.\n\n\nsource:\n\n\nRCall/src/callback.jl:102\n\n\n\n\n\n\nsexp(::Type{RCall.StrSxp},  s::Ptr{RCall.CharSxp}) \n\u00b6\n\n\nCreate a \nStrSxp\n from an \nAbstractString\n\n\nsource:\n\n\nRCall/src/convert-base.jl:77\n\n\n\n\n\n\nsexp(::Type{RCall.SymSxp},  s::AbstractString) \n\u00b6\n\n\nCreate a \nSymSxp\n from a \nSymbol\n\n\nsource:\n\n\nRCall/src/convert-base.jl:46\n\n\n\n\n\n\nsexp(p::Ptr{RCall.SxpHead}) \n\u00b6\n\n\nConvert a \nUnknownSxpPtr\n to an approptiate \nSxpPtr\n.\n\n\nsource:\n\n\nRCall/src/types.jl:330\n\n\n\n\n\n\nsexp(s::Symbol) \n\u00b6\n\n\nGeneric function for constructing Sxps from Julia objects.\n\n\nsource:\n\n\nRCall/src/convert-base.jl:50\n\n\n\n\n\n\nsexp_arglist_dots(args...) \n\u00b6\n\n\nCreate an argument list for an R function call, with a varargs \"dots\" at the end.\n\n\nsource:\n\n\nRCall/src/callback.jl:133\n\n\n\n\n\n\nsexpnum(h::RCall.SxpHead) \n\u00b6\n\n\nThe SEXPTYPE number of a \nSxp\n\n\nDetermined from the trailing 5 bits of the first 32-bit word. Is\na 0-based index into the \ninfo\n field of a \nSxpHead\n.\n\n\nsource:\n\n\nRCall/src/types.jl:309\n\n\n\n\n\n\nunprotect(n::Integer) \n\u00b6\n\n\nRelease last \nn\n objects gc-protected by \nprotect\n.\n\n\nsource:\n\n\nRCall/src/types.jl:301\n\n\n\n\n\n\nunsafe_array{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp}) \n\u00b6\n\n\nThe same as \nunsafe_vec\n, except returns an appropriately sized array.\n\n\nsource:\n\n\nRCall/src/methods.jl:70\n\n\n\n\n\n\nunsafe_vec{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp}) \n\u00b6\n\n\nRepresent the contents of a VectorSxp type as a \nVector\n.\n\n\nThis does \nnot\n copy the contents.  If the argument is not named (in R) or\notherwise protected from R's garbage collection (e.g. by keeping the\ncontaining RObject in scope) the contents of this vector can be modified or\ncould cause a memory error when accessed.\n\n\nThe contents are as stored in R.  Missing values (NA's) are represented\nin R by sentinels.  Missing data values in RealSxp and CplxSxp show\nup as \nNaN\n and \nNaN + NaNim\n, respectively.  Missing data in IntSxp show up\nas \n-2147483648\n, the minimum 32-bit integer value.  Internally a \nLglSxp\n is\nrepresented as \nVector{Int32}\n.  The convention is that \n0\n is \nfalse\n,\n\n-2147483648\n is \nNA\n and all other values represent \ntrue\n.\n\n\nsource:\n\n\nRCall/src/methods.jl:64\n\n\nTypes [Internal]\n\n\n\n\n\n\nRCall.AnySxp \n\u00b6\n\n\nR \"any\" object\n\n\nsource:\n\n\nRCall/src/types.jl:154\n\n\n\n\n\n\nRCall.BcodeSxp \n\u00b6\n\n\nR byte code\n\n\nsource:\n\n\nRCall/src/types.jl:176\n\n\n\n\n\n\nRCall.BuiltinSxp \n\u00b6\n\n\nR built-in function\n\n\nsource:\n\n\nRCall/src/types.jl:85\n\n\n\n\n\n\nRCall.DotSxp \n\u00b6\n\n\nR dot-dot-dot object\n\n\nsource:\n\n\nRCall/src/types.jl:148\n\n\n\n\n\n\nRCall.EnvSxp \n\u00b6\n\n\nR environment\n\n\nsource:\n\n\nRCall/src/types.jl:52\n\n\n\n\n\n\nRCall.ExprSxp \n\u00b6\n\n\nR expression vector\n\n\nsource:\n\n\nRCall/src/types.jl:168\n\n\n\n\n\n\nRCall.ExtPtrSxp \n\u00b6\n\n\nR external pointer\n\n\nsource:\n\n\nRCall/src/types.jl:182\n\n\n\n\n\n\nRCall.LangSxp \n\u00b6\n\n\nR function call\n\n\nsource:\n\n\nRCall/src/types.jl:70\n\n\n\n\n\n\nRCall.ListSxp \n\u00b6\n\n\nR pairs (cons) list cell\n\n\nsource:\n\n\nRCall/src/types.jl:34\n\n\n\n\n\n\nRCall.PromSxp \n\u00b6\n\n\nR promise\n\n\nsource:\n\n\nRCall/src/types.jl:61\n\n\n\n\n\n\nRCall.RawSxp \n\u00b6\n\n\nR byte vector\n\n\nsource:\n\n\nRCall/src/types.jl:197\n\n\n\n\n\n\nRCall.S4Sxp \n\u00b6\n\n\nR S4 object\n\n\nsource:\n\n\nRCall/src/types.jl:205\n\n\n\n\n\n\nRCall.SpecialSxp \n\u00b6\n\n\nR special function\n\n\nsource:\n\n\nRCall/src/types.jl:79\n\n\n\n\n\n\nRCall.SxpHead \n\u00b6\n\n\nR Sxp header: a pointer to this is used for unknown types.\n\n\nsource:\n\n\nRCall/src/types.jl:11\n\n\n\n\n\n\nRCall.SymSxp \n\u00b6\n\n\nR symbol\n\n\nsource:\n\n\nRCall/src/types.jl:99\n\n\n\n\n\n\nRCall.VecSxp \n\u00b6\n\n\nR list (i.e. Array{Any,1})\n\n\nsource:\n\n\nRCall/src/types.jl:160\n\n\n\n\n\n\nRCall.WeakRefSxp \n\u00b6\n\n\nR weak reference\n\n\nsource:\n\n\nRCall/src/types.jl:191\n\n\nGlobals [Internal]\n\n\n\n\n\n\njtypExtPtrs \n\u00b6\n\n\nJulia types (typically functions) which are wrapped in \nExtPtrSxpPtr\n are\nstored here to prevent garbage collection by Julia.\n\n\nsource:\n\n\nRCall/src/callback.jl:71\n\n\n\n\n\n\ntyps \n\u00b6\n\n\nvector of R Sxp types\n\n\nsource:\n\n\nRCall/src/types.jl:313", 
            "title": "RCall"
        }, 
        {
            "location": "/api/RCall/#rcall", 
            "text": "", 
            "title": "RCall"
        }, 
        {
            "location": "/api/RCall/#methods-exported", 
            "text": "anyNA{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})  \u00b6  Check if there are any NA values in the vector.  source:  RCall/src/methods.jl:309    getNames{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})  \u00b6  Returns the names of an R vector.  source:  RCall/src/methods.jl:234    isNA(x::Complex{Float64})  \u00b6  Check if values correspond to R's sentinel NA values.  source:  RCall/src/methods.jl:288    rcall(f,  args...)  \u00b6  Evaluate a function in the global environment. The first argument corresponds\nto the function to be called. It can be either a FunctionSxp type, a SymSxp or\na Symbol.  source:  RCall/src/functions.jl:25    rcopy(s::Ptr{RCall.SymSxp})  \u00b6  rcopy  copies the contents of an R object into a corresponding canonical Julia type.  source:  RCall/src/convert-default.jl:6    rcopy(str::AbstractString)  \u00b6  Evaluate and convert the result of a string as an R expression.  source:  RCall/src/iface.jl:40    rcopy{S :RCall.Sxp}(::Type{Any},  x::Ptr{S :RCall.Sxp})  \u00b6  rcopy(T,p)  converts a pointer  p  to a Sxp object to a native Julia object of type T.  rcopy(p)  performs a default conversion.  source:  RCall/src/convert-base.jl:9    reval(s)  \u00b6  Evaluate an R symbol or language object (i.e. a function call) in an R\ntry/catch block, returning an RObject.  source:  RCall/src/iface.jl:32    reval(s,  env)  \u00b6  Evaluate an R symbol or language object (i.e. a function call) in an R\ntry/catch block, returning an RObject.  source:  RCall/src/iface.jl:32    rparse(st::AbstractString)  \u00b6  Parse a string as an R expression, returning an RObject.  source:  RCall/src/iface.jl:63    rprint(io::IO,  str::ByteString)  \u00b6  Parse, evaluate and print the result of a string as an R expression.  source:  RCall/src/iface.jl:102    rprint{S :RCall.Sxp}(io::IO,  s::Ptr{S :RCall.Sxp})  \u00b6  Print the value of an Sxp using R's printing mechanism  source:  RCall/src/iface.jl:67    setNames!{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp},  n::Ptr{RCall.StrSxp})  \u00b6  Set the names of an R vector.  source:  RCall/src/methods.jl:240", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/RCall/#types-exported", 
            "text": "RCall.CharSxp  \u00b6  R character string  source:  RCall/src/types.jl:91    RCall.ClosSxp  \u00b6  R function closure  source:  RCall/src/types.jl:43    RCall.CplxSxp  \u00b6  R complex vector  source:  RCall/src/types.jl:132    RCall.IntSxp  \u00b6  R integer vector  source:  RCall/src/types.jl:116    RCall.LglSxp  \u00b6  R logical vector  source:  RCall/src/types.jl:108    RCall.NilSxp  \u00b6  R NULL value  source:  RCall/src/types.jl:28    RCall.RObject{S :RCall.Sxp}  \u00b6  An  RObject  is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the  RObject  itself is finalized by Julia. The parameter is the type of the S-expression.  When called with a Julia object as an argument, a corresponding R object is constructed.  julia  RObject(1)\nRObject{IntSxp}\n[1] 1\n\njulia  RObject(1:3)\nRObject{IntSxp}\n[1] 1 2 3\n\njulia  RObject(1.0:3.0)\nRObject{RealSxp}\n[1] 1 2 3  source:  RCall/src/types.jl:257    RCall.RealSxp  \u00b6  R real vector  source:  RCall/src/types.jl:124    RCall.StrSxp  \u00b6  R vector of character strings  source:  RCall/src/types.jl:140    RCall.Sxp  \u00b6  R symbolic expression ( SxpPtr ): these are represented by a pointer to a\nsymbolic expression record ( Sxp ).  source:  RCall/src/types.jl:5", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/RCall/#macros-exported", 
            "text": "@rget(args...)  \u00b6  Copies variables from R to Julia using the same name.  source:  RCall/src/iface.jl:128    @rput(args...)  \u00b6  Copies variables from Julia to R using the same name.  source:  RCall/src/iface.jl:108    @var_str(str)  \u00b6  Returns a variable named \"str\". Useful for passing keyword arguments containing dots.  source:  RCall/src/functions.jl:35", 
            "title": "Macros [Exported]"
        }, 
        {
            "location": "/api/RCall/#methods-internal", 
            "text": "NAel(::Type{RCall.LglSxp})  \u00b6  NA element for each type  source:  RCall/src/methods.jl:277    bound{S :RCall.Sxp}(s::Ptr{S :RCall.Sxp})  \u00b6  The R NAMED property, represented by 2 bits in the info field. This can take\nvalues 0,1 or 2, corresponding to whether it is bound to 0,1 or 2 or more\nsymbols. See\nhttp://cran.r-project.org/doc/manuals/r-patched/R-exts.html#Named-objects-and-copying  source:  RCall/src/methods.jl:12    callJuliaExtPtr(p::Ptr{RCall.ListSxp})  \u00b6  The function called by R .External for Julia callbacks.  It receives a  ListSxpPtr  containing\n - a pointer to the function itself ( ExtPtrSxpPtr )\n - a pointer to the Julia function ( ExtPtrSxpPtr )\n - any arguments (as  SxpPtr )  source:  RCall/src/callback.jl:32    dataptr{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})  \u00b6  Pointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.  source:  RCall/src/methods.jl:47    decrefExtPtr(p::Ptr{RCall.ExtPtrSxp})  \u00b6  Called by the R finalizer.  source:  RCall/src/callback.jl:76    eltype(::Type{RCall.LglSxp})  \u00b6  Element types of R vectors.  source:  RCall/src/types.jl:222    findNamespace(str::ByteString)  \u00b6  find namespace by name of the namespace  source:  RCall/src/methods.jl:386    getClass{S :RCall.Sxp}(s::Ptr{S :RCall.Sxp})  \u00b6  Returns the class of an R object.  source:  RCall/src/methods.jl:246    getindex(e::Ptr{RCall.EnvSxp},  s::Ptr{RCall.SymSxp})  \u00b6  extract the value of symbol s in the environment e  source:  RCall/src/methods.jl:354    getindex{S :RCall.PairListSxp}(l::Ptr{S :RCall.PairListSxp},  I::Integer)  \u00b6  extract the i-th element of LangSxp l  source:  RCall/src/methods.jl:177    getindex{S :RCall.VectorAtomicSxp}(s::Ptr{S :RCall.VectorAtomicSxp},  I::Real)  \u00b6  Indexing into  VectorSxp  types uses Julia indexing into the  vec  result,\nexcept for  StrSxp  and the  VectorListSxp  types, which must apply  sexp \nto the  Ptr{Void}  obtained by indexing into the  vec  result.  source:  RCall/src/methods.jl:80    getindex{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp},  label::AbstractString)  \u00b6  String indexing finds the first element with the matching name  source:  RCall/src/methods.jl:91    ijulia_displayplots()  \u00b6  Called after cell evaluation.\nCloses graphics device and displays files in notebook.  source:  RCall/src/IJulia.jl:53    ijulia_setdevice(m::MIME{mime})  \u00b6  Set options for R plotting with IJulia.  The first argument should be a MIME object: currently supported are   MIME(\"image/png\")  [default]   MIME(\"image/svg+xml\")  The remaining arguments (keyword only) are passed to the appropriate R graphics\ndevice: see the relevant R help for details.  source:  RCall/src/IJulia.jl:17    isascii(s::RCall.CharSxp)  \u00b6  Determines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).\n * 0x00_0002_00 (bit 1): set of bytes (no known encoding)\n * 0x00_0004_00 (bit 2): Latin-1\n * 0x00_0008_00 (bit 3): UTF-8\n * 0x00_0040_00 (bit 6): ASCII  We only support ASCII and UTF-8.  source:  RCall/src/methods.jl:330    length{S :RCall.Sxp}(s::Ptr{S :RCall.Sxp})  \u00b6  Sxp methods for  length  return the R length.  Rf_xlength  handles Sxps that are not vector-like and R's\n\"long vectors\", which have a negative value for the  length  member.  source:  RCall/src/methods.jl:24    makeExternalPtr(ptr::Ptr{Void})  \u00b6  Create an ExtPtrSxpPtr object  source:  RCall/src/callback.jl:18    makeExternalPtr(ptr::Ptr{Void},  tag)  \u00b6  Create an ExtPtrSxpPtr object  source:  RCall/src/callback.jl:18    makeExternalPtr(ptr::Ptr{Void},  tag,  prot)  \u00b6  Create an ExtPtrSxpPtr object  source:  RCall/src/callback.jl:18    makeNativeSymbol(fptr::Ptr{Void})  \u00b6  Register a function pointer as an R NativeSymbol.  This is completely undocumented, so may break: we technically are supposed to\nuse R_registerRoutines, but this is  much  easier for just 1 function.  source:  RCall/src/callback.jl:7    newEnvironment(env::Ptr{RCall.EnvSxp})  \u00b6  create a new environment which extends env  source:  RCall/src/methods.jl:380    preserve{S :RCall.Sxp}(p::Ptr{S :RCall.Sxp})  \u00b6  Prevent garbage collection of an R object. Object can be released via  release .  This is slower than  protect , as it requires searching an internal list, but\nmore flexible.  source:  RCall/src/types.jl:281    protect{S :RCall.Sxp}(p::Ptr{S :RCall.Sxp})  \u00b6  Stack-based protection of garbage collection of R objects. Objects are\nreleased via  unprotect . Returns the same pointer, allowing inline use.  This is faster than  preserve , but more restrictive. Really only useful\ninside functions.  source:  RCall/src/types.jl:296    registerFinalizer(s::Ptr{RCall.ExtPtrSxp})  \u00b6  Register finalizer to be called by the R GC.  source:  RCall/src/callback.jl:85    release{S :RCall.Sxp}(p::Ptr{S :RCall.Sxp})  \u00b6  Release object that has been gc protected by  preserve .  source:  RCall/src/types.jl:286    reval_p{S :RCall.Sxp}(expr::Ptr{S :RCall.Sxp},  env::Ptr{RCall.EnvSxp})  \u00b6  Evaluate an R symbol or language object (i.e. a function call) in an R\ntry/catch block, returning a Sxp pointer.  source:  RCall/src/iface.jl:5    rlang_p(f,  args...)  \u00b6  Create a function call from a list of arguments  source:  RCall/src/functions.jl:2    rparse_p(st::Ptr{RCall.StrSxp})  \u00b6  Parse a string as an R expression, returning a Sxp pointer.  source:  RCall/src/iface.jl:47    setClass!{S :RCall.Sxp}(s::Ptr{S :RCall.Sxp},  c::Ptr{RCall.StrSxp})  \u00b6  Set the class of an R object.  source:  RCall/src/methods.jl:253    setindex!{S :RCall.PairListSxp, T :RCall.Sxp}(l::Ptr{S :RCall.PairListSxp},  v::Ptr{T :RCall.Sxp},  I::Integer)  \u00b6  assign value v to the i-th element of LangSxp l  source:  RCall/src/methods.jl:188    setindex!{S :RCall.Sxp}(e::Ptr{RCall.EnvSxp},  v::Ptr{S :RCall.Sxp},  s::Ptr{RCall.SymSxp})  \u00b6  assign value v to symbol s in the environment e  source:  RCall/src/methods.jl:364    sexp(::Type{Int32},  x)  \u00b6  sexp(S,x)  converts a Julia object  x  to a pointer to a Sxp object of type  S .  sexp(x)  performs a default conversion.  source:  RCall/src/convert-base.jl:29    sexp(::Type{RCall.CharSxp},  st::ASCIIString)  \u00b6  Create a  CharSxp  from a String.  source:  RCall/src/convert-base.jl:63    sexp(::Type{RCall.ClosSxp},  f)  \u00b6  Wrap a callable Julia object  f  an a R  ClosSxpPtr .  Constructs the following R code  function(...) .External(rJuliaCallback, fExPtr, ...)  source:  RCall/src/callback.jl:118    sexp(::Type{RCall.ExtPtrSxp},  j)  \u00b6  Wrap a Julia object an a R  ExtPtrSxpPtr .  We store the pointer and the object in a const Dict to prevent it being\nremoved by the Julia GC.  source:  RCall/src/callback.jl:102    sexp(::Type{RCall.StrSxp},  s::Ptr{RCall.CharSxp})  \u00b6  Create a  StrSxp  from an  AbstractString  source:  RCall/src/convert-base.jl:77    sexp(::Type{RCall.SymSxp},  s::AbstractString)  \u00b6  Create a  SymSxp  from a  Symbol  source:  RCall/src/convert-base.jl:46    sexp(p::Ptr{RCall.SxpHead})  \u00b6  Convert a  UnknownSxpPtr  to an approptiate  SxpPtr .  source:  RCall/src/types.jl:330    sexp(s::Symbol)  \u00b6  Generic function for constructing Sxps from Julia objects.  source:  RCall/src/convert-base.jl:50    sexp_arglist_dots(args...)  \u00b6  Create an argument list for an R function call, with a varargs \"dots\" at the end.  source:  RCall/src/callback.jl:133    sexpnum(h::RCall.SxpHead)  \u00b6  The SEXPTYPE number of a  Sxp  Determined from the trailing 5 bits of the first 32-bit word. Is\na 0-based index into the  info  field of a  SxpHead .  source:  RCall/src/types.jl:309    unprotect(n::Integer)  \u00b6  Release last  n  objects gc-protected by  protect .  source:  RCall/src/types.jl:301    unsafe_array{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})  \u00b6  The same as  unsafe_vec , except returns an appropriately sized array.  source:  RCall/src/methods.jl:70    unsafe_vec{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})  \u00b6  Represent the contents of a VectorSxp type as a  Vector .  This does  not  copy the contents.  If the argument is not named (in R) or\notherwise protected from R's garbage collection (e.g. by keeping the\ncontaining RObject in scope) the contents of this vector can be modified or\ncould cause a memory error when accessed.  The contents are as stored in R.  Missing values (NA's) are represented\nin R by sentinels.  Missing data values in RealSxp and CplxSxp show\nup as  NaN  and  NaN + NaNim , respectively.  Missing data in IntSxp show up\nas  -2147483648 , the minimum 32-bit integer value.  Internally a  LglSxp  is\nrepresented as  Vector{Int32} .  The convention is that  0  is  false , -2147483648  is  NA  and all other values represent  true .  source:  RCall/src/methods.jl:64", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/RCall/#types-internal", 
            "text": "RCall.AnySxp  \u00b6  R \"any\" object  source:  RCall/src/types.jl:154    RCall.BcodeSxp  \u00b6  R byte code  source:  RCall/src/types.jl:176    RCall.BuiltinSxp  \u00b6  R built-in function  source:  RCall/src/types.jl:85    RCall.DotSxp  \u00b6  R dot-dot-dot object  source:  RCall/src/types.jl:148    RCall.EnvSxp  \u00b6  R environment  source:  RCall/src/types.jl:52    RCall.ExprSxp  \u00b6  R expression vector  source:  RCall/src/types.jl:168    RCall.ExtPtrSxp  \u00b6  R external pointer  source:  RCall/src/types.jl:182    RCall.LangSxp  \u00b6  R function call  source:  RCall/src/types.jl:70    RCall.ListSxp  \u00b6  R pairs (cons) list cell  source:  RCall/src/types.jl:34    RCall.PromSxp  \u00b6  R promise  source:  RCall/src/types.jl:61    RCall.RawSxp  \u00b6  R byte vector  source:  RCall/src/types.jl:197    RCall.S4Sxp  \u00b6  R S4 object  source:  RCall/src/types.jl:205    RCall.SpecialSxp  \u00b6  R special function  source:  RCall/src/types.jl:79    RCall.SxpHead  \u00b6  R Sxp header: a pointer to this is used for unknown types.  source:  RCall/src/types.jl:11    RCall.SymSxp  \u00b6  R symbol  source:  RCall/src/types.jl:99    RCall.VecSxp  \u00b6  R list (i.e. Array{Any,1})  source:  RCall/src/types.jl:160    RCall.WeakRefSxp  \u00b6  R weak reference  source:  RCall/src/types.jl:191", 
            "title": "Types [Internal]"
        }, 
        {
            "location": "/api/RCall/#globals-internal", 
            "text": "jtypExtPtrs  \u00b6  Julia types (typically functions) which are wrapped in  ExtPtrSxpPtr  are\nstored here to prevent garbage collection by Julia.  source:  RCall/src/callback.jl:71    typs  \u00b6  vector of R Sxp types  source:  RCall/src/types.jl:313", 
            "title": "Globals [Internal]"
        }, 
        {
            "location": "/api/", 
            "text": "API-INDEX\n\n\nMODULE: RCall\n\n\n\n\nMethods [Exported]\n\n\nanyNA{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp})\n  Check if there are any NA values in the vector.\n\n\ngetNames{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp})\n  Returns the names of an R vector.\n\n\nisNA(x::Complex{Float64})\n  Check if values correspond to R's sentinel NA values.\n\n\nrcall(f,  args...)\n  Evaluate a function in the global environment. The first argument corresponds\n\n\nrcopy(s::Ptr{RCall.SymSxp})\n  \nrcopy\n copies the contents of an R object into a corresponding canonical Julia type.\n\n\nrcopy(str::AbstractString)\n  Evaluate and convert the result of a string as an R expression.\n\n\nrcopy{S\n:RCall.Sxp}(::Type{Any},  x::Ptr{S\n:RCall.Sxp})\n  \nrcopy(T,p)\n converts a pointer \np\n to a Sxp object to a native Julia object of type T.\n\n\nreval(s)\n  Evaluate an R symbol or language object (i.e. a function call) in an R\n\n\nreval(s,  env)\n  Evaluate an R symbol or language object (i.e. a function call) in an R\n\n\nrparse(st::AbstractString)\n  Parse a string as an R expression, returning an RObject.\n\n\nrprint(io::IO,  str::ByteString)\n  Parse, evaluate and print the result of a string as an R expression.\n\n\nrprint{S\n:RCall.Sxp}(io::IO,  s::Ptr{S\n:RCall.Sxp})\n  Print the value of an Sxp using R's printing mechanism\n\n\nsetNames!{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp},  n::Ptr{RCall.StrSxp})\n  Set the names of an R vector.\n\n\n\n\nTypes [Exported]\n\n\nRCall.CharSxp\n  R character string\n\n\nRCall.ClosSxp\n  R function closure\n\n\nRCall.CplxSxp\n  R complex vector\n\n\nRCall.IntSxp\n  R integer vector\n\n\nRCall.LglSxp\n  R logical vector\n\n\nRCall.NilSxp\n  R NULL value\n\n\nRCall.RObject{S\n:RCall.Sxp}\n  An \nRObject\n is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the \nRObject\n itself is finalized by Julia. The parameter is the type of the S-expression.\n\n\nRCall.RealSxp\n  R real vector\n\n\nRCall.StrSxp\n  R vector of character strings\n\n\nRCall.Sxp\n  R symbolic expression (\nSxpPtr\n): these are represented by a pointer to a\n\n\n\n\nMacros [Exported]\n\n\n@rget(args...)\n  Copies variables from R to Julia using the same name.\n\n\n@rput(args...)\n  Copies variables from Julia to R using the same name.\n\n\n@var_str(str)\n  Returns a variable named \"str\". Useful for passing keyword arguments containing dots.\n\n\n\n\nMethods [Internal]\n\n\nNAel(::Type{RCall.LglSxp})\n  NA element for each type\n\n\nbound{S\n:RCall.Sxp}(s::Ptr{S\n:RCall.Sxp})\n  The R NAMED property, represented by 2 bits in the info field. This can take\n\n\ncallJuliaExtPtr(p::Ptr{RCall.ListSxp})\n  The function called by R .External for Julia callbacks.\n\n\ndataptr{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp})\n  Pointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.\n\n\ndecrefExtPtr(p::Ptr{RCall.ExtPtrSxp})\n  Called by the R finalizer.\n\n\neltype(::Type{RCall.LglSxp})\n  Element types of R vectors.\n\n\nfindNamespace(str::ByteString)\n  find namespace by name of the namespace\n\n\ngetClass{S\n:RCall.Sxp}(s::Ptr{S\n:RCall.Sxp})\n  Returns the class of an R object.\n\n\ngetindex(e::Ptr{RCall.EnvSxp},  s::Ptr{RCall.SymSxp})\n  extract the value of symbol s in the environment e\n\n\ngetindex{S\n:RCall.PairListSxp}(l::Ptr{S\n:RCall.PairListSxp},  I::Integer)\n  extract the i-th element of LangSxp l\n\n\ngetindex{S\n:RCall.VectorAtomicSxp}(s::Ptr{S\n:RCall.VectorAtomicSxp},  I::Real)\n  Indexing into \nVectorSxp\n types uses Julia indexing into the \nvec\n result,\n\n\ngetindex{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp},  label::AbstractString)\n  String indexing finds the first element with the matching name\n\n\nijulia_displayplots()\n  Called after cell evaluation.\n\n\nijulia_setdevice(m::MIME{mime})\n  Set options for R plotting with IJulia.\n\n\nisascii(s::RCall.CharSxp)\n  Determines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).\n\n\nlength{S\n:RCall.Sxp}(s::Ptr{S\n:RCall.Sxp})\n  Sxp methods for \nlength\n return the R length.\n\n\nmakeExternalPtr(ptr::Ptr{Void})\n  Create an ExtPtrSxpPtr object\n\n\nmakeExternalPtr(ptr::Ptr{Void},  tag)\n  Create an ExtPtrSxpPtr object\n\n\nmakeExternalPtr(ptr::Ptr{Void},  tag,  prot)\n  Create an ExtPtrSxpPtr object\n\n\nmakeNativeSymbol(fptr::Ptr{Void})\n  Register a function pointer as an R NativeSymbol.\n\n\nnewEnvironment(env::Ptr{RCall.EnvSxp})\n  create a new environment which extends env\n\n\npreserve{S\n:RCall.Sxp}(p::Ptr{S\n:RCall.Sxp})\n  Prevent garbage collection of an R object. Object can be released via \nrelease\n.\n\n\nprotect{S\n:RCall.Sxp}(p::Ptr{S\n:RCall.Sxp})\n  Stack-based protection of garbage collection of R objects. Objects are\n\n\nregisterFinalizer(s::Ptr{RCall.ExtPtrSxp})\n  Register finalizer to be called by the R GC.\n\n\nrelease{S\n:RCall.Sxp}(p::Ptr{S\n:RCall.Sxp})\n  Release object that has been gc protected by \npreserve\n.\n\n\nreval_p{S\n:RCall.Sxp}(expr::Ptr{S\n:RCall.Sxp},  env::Ptr{RCall.EnvSxp})\n  Evaluate an R symbol or language object (i.e. a function call) in an R\n\n\nrlang_p(f,  args...)\n  Create a function call from a list of arguments\n\n\nrparse_p(st::Ptr{RCall.StrSxp})\n  Parse a string as an R expression, returning a Sxp pointer.\n\n\nsetClass!{S\n:RCall.Sxp}(s::Ptr{S\n:RCall.Sxp},  c::Ptr{RCall.StrSxp})\n  Set the class of an R object.\n\n\nsetindex!{S\n:RCall.PairListSxp, T\n:RCall.Sxp}(l::Ptr{S\n:RCall.PairListSxp},  v::Ptr{T\n:RCall.Sxp},  I::Integer)\n  assign value v to the i-th element of LangSxp l\n\n\nsetindex!{S\n:RCall.Sxp}(e::Ptr{RCall.EnvSxp},  v::Ptr{S\n:RCall.Sxp},  s::Ptr{RCall.SymSxp})\n  assign value v to symbol s in the environment e\n\n\nsexp(::Type{Int32},  x)\n  \nsexp(S,x)\n converts a Julia object \nx\n to a pointer to a Sxp object of type \nS\n.\n\n\nsexp(::Type{RCall.CharSxp},  st::ASCIIString)\n  Create a \nCharSxp\n from a String.\n\n\nsexp(::Type{RCall.ClosSxp},  f)\n  Wrap a callable Julia object \nf\n an a R \nClosSxpPtr\n.\n\n\nsexp(::Type{RCall.ExtPtrSxp},  j)\n  Wrap a Julia object an a R \nExtPtrSxpPtr\n.\n\n\nsexp(::Type{RCall.StrSxp},  s::Ptr{RCall.CharSxp})\n  Create a \nStrSxp\n from an \nAbstractString\n\n\nsexp(::Type{RCall.SymSxp},  s::AbstractString)\n  Create a \nSymSxp\n from a \nSymbol\n\n\nsexp(p::Ptr{RCall.SxpHead})\n  Convert a \nUnknownSxpPtr\n to an approptiate \nSxpPtr\n.\n\n\nsexp(s::Symbol)\n  Generic function for constructing Sxps from Julia objects.\n\n\nsexp_arglist_dots(args...)\n  Create an argument list for an R function call, with a varargs \"dots\" at the end.\n\n\nsexpnum(h::RCall.SxpHead)\n  The SEXPTYPE number of a \nSxp\n\n\nunprotect(n::Integer)\n  Release last \nn\n objects gc-protected by \nprotect\n.\n\n\nunsafe_array{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp})\n  The same as \nunsafe_vec\n, except returns an appropriately sized array.\n\n\nunsafe_vec{S\n:RCall.VectorSxp}(s::Ptr{S\n:RCall.VectorSxp})\n  Represent the contents of a VectorSxp type as a \nVector\n.\n\n\n\n\nTypes [Internal]\n\n\nRCall.AnySxp\n  R \"any\" object\n\n\nRCall.BcodeSxp\n  R byte code\n\n\nRCall.BuiltinSxp\n  R built-in function\n\n\nRCall.DotSxp\n  R dot-dot-dot object\n\n\nRCall.EnvSxp\n  R environment\n\n\nRCall.ExprSxp\n  R expression vector\n\n\nRCall.ExtPtrSxp\n  R external pointer\n\n\nRCall.LangSxp\n  R function call\n\n\nRCall.ListSxp\n  R pairs (cons) list cell\n\n\nRCall.PromSxp\n  R promise\n\n\nRCall.RawSxp\n  R byte vector\n\n\nRCall.S4Sxp\n  R S4 object\n\n\nRCall.SpecialSxp\n  R special function\n\n\nRCall.SxpHead\n  R Sxp header: a pointer to this is used for unknown types.\n\n\nRCall.SymSxp\n  R symbol\n\n\nRCall.VecSxp\n  R list (i.e. Array{Any,1})\n\n\nRCall.WeakRefSxp\n  R weak reference\n\n\n\n\nGlobals [Internal]\n\n\njtypExtPtrs\n  Julia types (typically functions) which are wrapped in \nExtPtrSxpPtr\n are\n\n\ntyps\n  vector of R Sxp types", 
            "title": "Index"
        }, 
        {
            "location": "/api/#api-index", 
            "text": "", 
            "title": "API-INDEX"
        }, 
        {
            "location": "/api/#module-rcall", 
            "text": "", 
            "title": "MODULE: RCall"
        }, 
        {
            "location": "/api/#methods-exported", 
            "text": "anyNA{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})   Check if there are any NA values in the vector.  getNames{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})   Returns the names of an R vector.  isNA(x::Complex{Float64})   Check if values correspond to R's sentinel NA values.  rcall(f,  args...)   Evaluate a function in the global environment. The first argument corresponds  rcopy(s::Ptr{RCall.SymSxp})    rcopy  copies the contents of an R object into a corresponding canonical Julia type.  rcopy(str::AbstractString)   Evaluate and convert the result of a string as an R expression.  rcopy{S :RCall.Sxp}(::Type{Any},  x::Ptr{S :RCall.Sxp})    rcopy(T,p)  converts a pointer  p  to a Sxp object to a native Julia object of type T.  reval(s)   Evaluate an R symbol or language object (i.e. a function call) in an R  reval(s,  env)   Evaluate an R symbol or language object (i.e. a function call) in an R  rparse(st::AbstractString)   Parse a string as an R expression, returning an RObject.  rprint(io::IO,  str::ByteString)   Parse, evaluate and print the result of a string as an R expression.  rprint{S :RCall.Sxp}(io::IO,  s::Ptr{S :RCall.Sxp})   Print the value of an Sxp using R's printing mechanism  setNames!{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp},  n::Ptr{RCall.StrSxp})   Set the names of an R vector.", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/#types-exported", 
            "text": "RCall.CharSxp   R character string  RCall.ClosSxp   R function closure  RCall.CplxSxp   R complex vector  RCall.IntSxp   R integer vector  RCall.LglSxp   R logical vector  RCall.NilSxp   R NULL value  RCall.RObject{S :RCall.Sxp}   An  RObject  is a Julia wrapper for an R object (known as an \"S-expression\" or \"SEXP\"). It is stored as a pointer which is protected from the R garbage collector, until the  RObject  itself is finalized by Julia. The parameter is the type of the S-expression.  RCall.RealSxp   R real vector  RCall.StrSxp   R vector of character strings  RCall.Sxp   R symbolic expression ( SxpPtr ): these are represented by a pointer to a", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/#macros-exported", 
            "text": "@rget(args...)   Copies variables from R to Julia using the same name.  @rput(args...)   Copies variables from Julia to R using the same name.  @var_str(str)   Returns a variable named \"str\". Useful for passing keyword arguments containing dots.", 
            "title": "Macros [Exported]"
        }, 
        {
            "location": "/api/#methods-internal", 
            "text": "NAel(::Type{RCall.LglSxp})   NA element for each type  bound{S :RCall.Sxp}(s::Ptr{S :RCall.Sxp})   The R NAMED property, represented by 2 bits in the info field. This can take  callJuliaExtPtr(p::Ptr{RCall.ListSxp})   The function called by R .External for Julia callbacks.  dataptr{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})   Pointer to start of the data array in a SEXPREC. Corresponds to DATAPTR C macro.  decrefExtPtr(p::Ptr{RCall.ExtPtrSxp})   Called by the R finalizer.  eltype(::Type{RCall.LglSxp})   Element types of R vectors.  findNamespace(str::ByteString)   find namespace by name of the namespace  getClass{S :RCall.Sxp}(s::Ptr{S :RCall.Sxp})   Returns the class of an R object.  getindex(e::Ptr{RCall.EnvSxp},  s::Ptr{RCall.SymSxp})   extract the value of symbol s in the environment e  getindex{S :RCall.PairListSxp}(l::Ptr{S :RCall.PairListSxp},  I::Integer)   extract the i-th element of LangSxp l  getindex{S :RCall.VectorAtomicSxp}(s::Ptr{S :RCall.VectorAtomicSxp},  I::Real)   Indexing into  VectorSxp  types uses Julia indexing into the  vec  result,  getindex{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp},  label::AbstractString)   String indexing finds the first element with the matching name  ijulia_displayplots()   Called after cell evaluation.  ijulia_setdevice(m::MIME{mime})   Set options for R plotting with IJulia.  isascii(s::RCall.CharSxp)   Determines the encoding of the CharSxp. This is determined by the 'gp' part of the sxpinfo (this is the middle 16 bits).  length{S :RCall.Sxp}(s::Ptr{S :RCall.Sxp})   Sxp methods for  length  return the R length.  makeExternalPtr(ptr::Ptr{Void})   Create an ExtPtrSxpPtr object  makeExternalPtr(ptr::Ptr{Void},  tag)   Create an ExtPtrSxpPtr object  makeExternalPtr(ptr::Ptr{Void},  tag,  prot)   Create an ExtPtrSxpPtr object  makeNativeSymbol(fptr::Ptr{Void})   Register a function pointer as an R NativeSymbol.  newEnvironment(env::Ptr{RCall.EnvSxp})   create a new environment which extends env  preserve{S :RCall.Sxp}(p::Ptr{S :RCall.Sxp})   Prevent garbage collection of an R object. Object can be released via  release .  protect{S :RCall.Sxp}(p::Ptr{S :RCall.Sxp})   Stack-based protection of garbage collection of R objects. Objects are  registerFinalizer(s::Ptr{RCall.ExtPtrSxp})   Register finalizer to be called by the R GC.  release{S :RCall.Sxp}(p::Ptr{S :RCall.Sxp})   Release object that has been gc protected by  preserve .  reval_p{S :RCall.Sxp}(expr::Ptr{S :RCall.Sxp},  env::Ptr{RCall.EnvSxp})   Evaluate an R symbol or language object (i.e. a function call) in an R  rlang_p(f,  args...)   Create a function call from a list of arguments  rparse_p(st::Ptr{RCall.StrSxp})   Parse a string as an R expression, returning a Sxp pointer.  setClass!{S :RCall.Sxp}(s::Ptr{S :RCall.Sxp},  c::Ptr{RCall.StrSxp})   Set the class of an R object.  setindex!{S :RCall.PairListSxp, T :RCall.Sxp}(l::Ptr{S :RCall.PairListSxp},  v::Ptr{T :RCall.Sxp},  I::Integer)   assign value v to the i-th element of LangSxp l  setindex!{S :RCall.Sxp}(e::Ptr{RCall.EnvSxp},  v::Ptr{S :RCall.Sxp},  s::Ptr{RCall.SymSxp})   assign value v to symbol s in the environment e  sexp(::Type{Int32},  x)    sexp(S,x)  converts a Julia object  x  to a pointer to a Sxp object of type  S .  sexp(::Type{RCall.CharSxp},  st::ASCIIString)   Create a  CharSxp  from a String.  sexp(::Type{RCall.ClosSxp},  f)   Wrap a callable Julia object  f  an a R  ClosSxpPtr .  sexp(::Type{RCall.ExtPtrSxp},  j)   Wrap a Julia object an a R  ExtPtrSxpPtr .  sexp(::Type{RCall.StrSxp},  s::Ptr{RCall.CharSxp})   Create a  StrSxp  from an  AbstractString  sexp(::Type{RCall.SymSxp},  s::AbstractString)   Create a  SymSxp  from a  Symbol  sexp(p::Ptr{RCall.SxpHead})   Convert a  UnknownSxpPtr  to an approptiate  SxpPtr .  sexp(s::Symbol)   Generic function for constructing Sxps from Julia objects.  sexp_arglist_dots(args...)   Create an argument list for an R function call, with a varargs \"dots\" at the end.  sexpnum(h::RCall.SxpHead)   The SEXPTYPE number of a  Sxp  unprotect(n::Integer)   Release last  n  objects gc-protected by  protect .  unsafe_array{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})   The same as  unsafe_vec , except returns an appropriately sized array.  unsafe_vec{S :RCall.VectorSxp}(s::Ptr{S :RCall.VectorSxp})   Represent the contents of a VectorSxp type as a  Vector .", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/#types-internal", 
            "text": "RCall.AnySxp   R \"any\" object  RCall.BcodeSxp   R byte code  RCall.BuiltinSxp   R built-in function  RCall.DotSxp   R dot-dot-dot object  RCall.EnvSxp   R environment  RCall.ExprSxp   R expression vector  RCall.ExtPtrSxp   R external pointer  RCall.LangSxp   R function call  RCall.ListSxp   R pairs (cons) list cell  RCall.PromSxp   R promise  RCall.RawSxp   R byte vector  RCall.S4Sxp   R S4 object  RCall.SpecialSxp   R special function  RCall.SxpHead   R Sxp header: a pointer to this is used for unknown types.  RCall.SymSxp   R symbol  RCall.VecSxp   R list (i.e. Array{Any,1})  RCall.WeakRefSxp   R weak reference", 
            "title": "Types [Internal]"
        }, 
        {
            "location": "/api/#globals-internal", 
            "text": "jtypExtPtrs   Julia types (typically functions) which are wrapped in  ExtPtrSxpPtr  are  typs   vector of R Sxp types", 
            "title": "Globals [Internal]"
        }
    ]
}